{"pages":[{"title":"关于我","text":"本人为华南理工大学 级软件工程专业在校生，此blog用来记录日常与学习心得 可以通过以下方式找到我： WeChat：wsy_jim Github：wsyunine bilibili ：wsy_jim","link":"/about/index.html"},{"title":"友链","text":"Friends Interesting Things","link":"/links/index.html"}],"posts":[{"title":"ABC320","text":"写在前面： 菜菜 A 小小签到题，不能用 ，会爆 B 签到题， 判回文 C 老虎机 先枚举数码，再枚举顺序，然后模拟，考码力 D 双向建图跑 E 离散化后，排序模拟，要注意吃不到的情况，没有人退出或回来 F DP，不会做 三维DP 顺推，向外更新，比另一种方法好写多了 会点了，但不想写了 好像假了 正推比逆推少过了仨点 难受 回头再说 G 加强版老虎机 二分+二分图 暂时咕","link":"/2023/09/19/ABC320/"},{"title":"AppleScript学习笔记","text":"写在前面：在搭建班级代码仓库时遇到了需要编写脚本的问题，所以来学习一下怎么编写 ，感觉用好了这门脚本语言 将会很强大 我不用学了，因为 帮我学了 脚本1： 用来分类文件 在文件夹1下有一些文件，文件名前两个数码为序号，在文件夹2下有一些文件夹，文件夹名为序号，现在要求运行脚本后，存在文件夹1下的所有文件按照序号复制一份到文件夹2下对应名字的文件夹下 12345678910111213141516171819202122232425262728-- 设置文件夹路径set folder1Path to \"路径1\"set folder2Path to \"路径2\"-- 获取文件夹1中的所有文件tell application \"System Events\" set folder1Files to every file of folder folder1Pathend tell-- 遍历文件并复制到相应的文件夹中repeat with aFile in folder1Files set filePath to POSIX path of (aFile as alias) set fileName to name of aFile -- 提取文件名前两个数码作为序号 set serialNumber to text 1 thru 2 of fileName -- 确定目标文件夹的路径 set targetFolder to folder2Path &amp; \"/\" &amp; serialNumber -- 如果目标文件夹不存在，则创建它 do shell script \"mkdir -p \" &amp; quoted form of POSIX path of targetFolder -- 使用 shell 命令复制文件 do shell script \"cp \" &amp; quoted form of filePath &amp; \" \" &amp; quoted form of POSIX path of targetFolderend repeatdisplay dialog \"复制完成！\" 脚本2： 用来创建文件夹 在文件夹中创建名为 01、02、……、62 的总共62个文件夹。 1234567891011-- 设置文件夹1路径set folder1Path to \"路径\" -- 请将路径替换为实际路径-- 创建文件夹repeat with i from 1 to 62 set folderNumber to text -2 thru -1 of (\"0\" &amp; i) -- 将数字转为两位数格式，如1变为01 set newFolderPath to folder1Path &amp; \"/\" &amp; folderNumber do shell script \"mkdir -p \" &amp; quoted form of newFolderPathend repeatdisplay dialog \"创建完成！\"","link":"/2023/09/16/AppleScript/"},{"title":"CF1872","text":"写在前面： 到学校第一次打 还算可以 A 签到题，基本运算，读懂题即可 ceil(x) 是对 向上取整，floor(x) 是对 向下取整 B 签到题，读懂题即可，线性扫陷阱 C 小构造题，如果范围里有大于 的偶数，那就输出 和 ，如果只有一个奇数，那就分解因数，如果有除 和它本身的因数，就输出此因数和 与此因数的差，找不到就输出 ，注意 都不符合题意需特判 D 小数学题，发现 的倍数数量相对于整体是少数，所以只需要考虑倍数， 的公倍数被加一次减一次相当于没用，于是我们求出来是 的倍数但不是 的倍数的个数以及是 的倍数但不是 的倍数的个数，依次把最大的若干数和最小的若干数填进去即可 E 看到几种做法 1. 线段树（我的做法） 2. 异或前缀和 3. 分块 感觉线段树还是比较好想的，维护区间内属于 的异或和属于 的异或和，修改就是 并打 ，我做的时候出现了一些问题，导致样例能过，但是第二个点就过不去了，最后几分钟调出来了，发现是打 的方式不对，有的 不能及时下放，在 本来就为 的节点再进行修改， 应该变为 ，我忽略了这个问题，最后切了 F 基环树森林的基本做法，先处理环下树一定最优，然后找环，环中舍掉贡献最少的边，定出一个起点按顺序输出，最劣复杂度 在一个有向图中,每一个点都有唯一的一个出边,那么这个图就是一棵基环树。 G 奇技淫巧题 发现操作肯定是选非 的数做两端更优，所以只需要枚举非 的数，处理出前缀积和前缀和，然后 枚举，有人担心 过不了，其实确实过不了，考虑一些可以直接得出答案的情况，当一段数的积够大，大到一定程度，就一定取整段 数据范围告诉我们如果什么操作都不做，所有数的和最大应该是 ，当积大于这个数时，就可以省去枚举的步骤，以 为底其的对数不超过 ，枚举飞快 第一次手撕 题纪念一下","link":"/2023/09/08/CF1872/"},{"title":"CF1879","text":"写在前面： 的 A 签到题，注意读题，特判后直接输出答案 B 符合条件的摆法，一定满足每行都有或者每列都有 所以按行取一次最小值再按列取一次最小值，输出两次的最小值 C 小小计数题 预处理出 以及 如果有连续的一串 或 ，在 个里面取 个，最后再乘上操作数的阶乘 D 求全部区间的区间长度 元素异或和 先考虑 时的做法 求出来异或前缀和，对于一个选定的区间右端点，如果该点异或前缀和为 ，那么左端点的异或前缀和只能是 ，该区间才对答案有贡献，另外一种情况也一样，于是我们扫一遍序列，分别记录 和 的个数以及到右端点的距离之和，有点小技巧，每次扫到 时就加上 对应的距离和，每次扫到 时就加上 对应的距离和，细节处理一下就好 然后 就按位拆开分别处理即可 E 交互题，想假了 一开始的做法： 对于一个点，其连儿子的边都是一种颜色，连父亲的边是另一种颜色，当一个点有大于 个儿子时，可以通过数量判断父亲，一棵树都是这样的节点的话，就只需要两种颜色，当一个点只有一个儿子时，就是需要引入另一种颜色，所以我们只需要统计儿子个数之为 的点形成的链的最大长度即可，最小颜色就是 实际上，想复杂了 颜色最多 种 对于多个儿子的节点直接找 ，对于一个儿子的点，相邻边存在的颜色也最多只有 种，颜色对 取模后就完全可以确定边的优先级 还有一个点就是 连儿子的边的颜色可以不相同 贴个代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;climits&gt;#include&lt;iomanip&gt;using namespace std;#define N 100010template&lt;typename T&gt;inline void read(T &amp;x){ x=0;bool flg=0;char c=getchar(); for(;!isdigit(c);c=getchar()) if(c=='-') flg=1; for(;isdigit(c);c=getchar()) x=x*10+(c^48); if(flg) x=-x;}int n,p[N];vector&lt;int&gt; e[110];int cl[N],mx[110],dmx=0;void dfs1(int x,int c){ cl[x]=c;dmx=max(dmx,c); for(auto i:e[x]){ if(e[x].size()==1) dfs1(i,c%3+1); else{ if(c!=1) dfs1(i,1); else dfs1(i,2); } }}int main(){ read(n); for(int i=2;i&lt;=n;i++) read(p[i]),e[p[i]].push_back(i); for(int i=0;i&lt;e[1].size();i++){ dmx=1; dfs1(e[1][i],1); if(dmx==1){mx[i]=1;continue;} else if(dmx==2){mx[i]=2;continue;} else{ dmx=2; dfs1(e[1][i],2); if(dmx==2) mx[i]=2; else mx[i]=3; } } for(int i=0;i&lt;e[1].size();i++) dmx=max(dmx,mx[i]); cout&lt;&lt;dmx&lt;&lt;endl; for(int i=2;i&lt;=n;i++) cout&lt;&lt;cl[i]&lt;&lt;\" \"; cout&lt;&lt;endl; int op; read(op); while(op==0){ int tmp=0; for(int i=1,o=1;i&lt;=dmx;i++,o*=2){ int a; read(a); if(a==1) tmp+=o; } if(tmp==1||tmp==3) cout&lt;&lt;1&lt;&lt;endl; else if(tmp==2||tmp==6) cout&lt;&lt;2&lt;&lt;endl; else cout&lt;&lt;3&lt;&lt;endl; read(op); } return 0;} F 问题转换：对于 从 枚举到 ，求出 第一大的下标和值以及第二大的值 数论分块+ST表 调死我了 对于每个 ，按 分块，由调和级数，遍历的复杂度也不会超过 ，于是只需对 处理 查询第一大的下标和值以及第二大的值， 表改改就行了，但是💩山代码 贴个代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;climits&gt;#include&lt;iomanip&gt;using namespace std;#define N 400010#define ll long longtemplate&lt;typename T&gt;inline void read(T &amp;x){ x=0;bool flg=0;char c=getchar(); for(;!isdigit(c);c=getchar()) if(c=='-') flg=1; for(;isdigit(c);c=getchar()) x=x*10+(c^48); if(flg) x=-x;}int t;int mx=0;ll ans[N];int n,f1[30][N],f2[30][N],g[30][N],lg[N]={-1};int a[N];struct inp{ int h,a; int num;}p[N];struct node{ ll idx,k1,k2;};bool cmp(inp a,inp b){ return a.a&lt;b.a;}void init(){ for(int i=1;i&lt;=n;i++) f1[0][i]=p[i].h,f2[0][i]=0,lg[i]=lg[i/2]+1,g[0][i]=p[i].num; for(int i=1;i&lt;=lg[n];i++){ for(int j=1;j+(1&lt;&lt;i)-1&lt;=n;j++){ if(f1[i-1][j]&lt;f1[i-1][j+(1&lt;&lt;(i-1))]){ f1[i][j]=f1[i-1][j+(1&lt;&lt;(i-1))]; g[i][j]=g[i-1][j+(1&lt;&lt;(i-1))]; f2[i][j]=max(f1[i-1][j],f2[i-1][j+(1&lt;&lt;(i-1))]); }else if(f1[i-1][j]&gt;f1[i-1][j+(1&lt;&lt;(i-1))]){ f1[i][j]=f1[i-1][j]; g[i][j]=g[i-1][j]; f2[i][j]=max(f2[i-1][j],f1[i-1][j+(1&lt;&lt;(i-1))]); }else{ f1[i][j]=f1[i-1][j]; g[i][j]=-1; f2[i][j]=max(f2[i-1][j],f2[i-1][j+(1&lt;&lt;(i-1))]); } } }}node query(int l,int r){ node ans; int len=lg[r-l+1]; if(f1[len][l]&gt;f1[len][r-(1&lt;&lt;len)+1]){ ans.k1=f1[len][l]; ans.idx=g[len][l]; ans.k2=max(f1[len][r-(1&lt;&lt;len)+1],f2[len][l]); }else if(f1[len][l]&lt;f1[len][r-(1&lt;&lt;len)+1]){ ans.k1=f1[len][r-(1&lt;&lt;len)+1]; ans.idx=g[len][r-(1&lt;&lt;len)+1]; ans.k2=max(f2[len][r-(1&lt;&lt;len)+1],f1[len][l]); }else{ ans.k1=f1[len][l]; ans.k2=max(f2[len][l],f2[len][r-(1&lt;&lt;len)+1]); if(g[len][l]==g[len][r-(1&lt;&lt;len)+1]) ans.idx=g[len][l]; else ans.idx=-1; } return ans;}int main(){ read(t); while(t--){ read(n);mx=0; for(int i=1;i&lt;=n;i++) read(p[i].h),p[i].num=i,ans[i]=0; for(int i=1;i&lt;=n;i++) read(p[i].a),mx=max(mx,p[i].a); sort(p+1,p+1+n,cmp); for(int i=1;i&lt;=n;i++) a[i]=p[i].a; init(); for(int i=1;i&lt;=mx;i++){ node tmp,ad; ad.idx=0,ad.k1=0,ad.k2=0; // cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;ceil((1.0*mx)/(1.0*i))&lt;&lt;endl; for(int c=1;c&lt;=ceil((1.0*mx)/(1.0*i));c++){ int l=lower_bound(a+1,a+n+1,i*(c-1)+1)-a; int r=upper_bound(a+1,a+n+1,i*c)-a-1; // cout&lt;&lt;i*(c-1)+1&lt;&lt;\" \"&lt;&lt;i*c&lt;&lt;\" \"&lt;&lt;l&lt;&lt;\" \"&lt;&lt;r&lt;&lt;endl; if(l&gt;r) continue; tmp=query(l,r); // cout&lt;&lt;l&lt;&lt;\" \"&lt;&lt;r&lt;&lt;\" \"&lt;&lt;tmp.k1&lt;&lt;\" \"&lt;&lt;tmp.idx&lt;&lt;\" \"&lt;&lt;tmp.k2&lt;&lt;endl; if(tmp.k1*c&gt;ad.k1){ ad.k2=max(ad.k1,tmp.k2*c); ad.k1=tmp.k1*c; ad.idx=tmp.idx; }else if(tmp.k1*c&lt;ad.k1){ ad.k2=max(ad.k2,tmp.k1*c); }else{ ad.idx=-1; ad.k2=max(ad.k2,tmp.k2*c); } } // cout&lt;&lt;ad.k1&lt;&lt;\" \"&lt;&lt;ad.idx&lt;&lt;\" \"&lt;&lt;ad.k2&lt;&lt;endl; if(ad.idx==-1) continue; ans[ad.idx]=max(ans[ad.idx],ad.k1-ad.k2); } for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;\" \"; cout&lt;&lt;endl; } return 0;}","link":"/2023/09/26/CF1879/"},{"title":"CF1882","text":"写在前面： 睡觉场 A 签到，以 或 开头，扫过去 B 不太友好的 重构了一遍 思想就是试着每次去除集合里的一个元素，并且模拟一下看看连带着会去除多少别的元素，肯定是去除的越少越好，考验码力 C 写完 看完 就睡了","link":"/2023/09/30/CF1882/"},{"title":"CMU15445_learning_note","text":"学一学CMU的15445 Projects #0 - C++ Primer C++ Bootcamp 主要针对 C++17 特性，共 个文件。 references.cpp 有关引用（别名），函数传引用 move_semantics.cpp 有关移动语义和右值引用 lvalue（左值）：refer to 内存中某个有权限访问的区域的对象 rvalue（右值）：非左值的值，数据位于的区域没有权限访问（字面常量）或者没有必要访问（匿名对象），包括将亡值和纯右值 赋值语句中等号左边的必须是左值，右边的随便 左值引用（&amp;）和右值引用（&amp;&amp;）都必须立即初始化，右值引用可以通过移动的方式在浅拷贝的情况下保证拷贝的安全性，在设计和实现类时，对于需要动态申请大量资源的类，应该设计右值引用的拷贝构造函数和赋值函数，以提高应用程序的效率，具体 3. 中有讲 std::move() 方法可以将左值转换为右值，即将亡值，方便使用移动语义，需要 &lt;utility&gt; 头文件 move_constructors.cpp 有关应用移动语义的拷贝构造函数和赋值重载函数 在类定义中删除左值引用的拷贝构造函数和赋值重载函数，意味着实例化后就不再允许被复制，防止双重删除或者内存泄露 References： C++11右值引用|移动语义|完美转发|巨巨巨详细 C++|左值、右值、将亡值|谈谈我对它们的深入理解 templated_functions.cpp 有关模板函数 注意模板参数不一定要是 class 或者 typename，也可以是别的，但没必要 templated_classes.cpp 有关模板类 wrapper_class.cpp 有关包装类 RAII（Resource Acquisition is Initialization）：一个实例化管理一个资源，防止双重删除或内存泄露 使用移动语义 iterator.cpp 有关迭代器，实现了一个双向链表（DLL）及其迭代器 namespaces.cpp 有关命名空间 vectors.cpp 有关动态数组 std::remove_if() 不能删除元素，只能将元素移到末尾，配合 erase() 函数才能删掉 emplace_back() 比 push_back() 稍快 sets.cpp 有关集合 count() 函数 unordered_maps.cpp 有关映射 count() 函数 auto.cpp 有关 auto 类型使用 unique_ptr.cpp 有关智能指针类型 unique_ptr 使用 需要 &lt;memory&gt; 头文件 unique_ptr 保留对象的唯一所有权，没有两个 unique_ptr 指针指向同一个对象 初始化 12//利用make_unique&lt;&gt;()方法初始化，调用的构造函数是&lt;&gt;类型的构造函数std::unique_ptr&lt;Point&gt; u = std::make_unique&lt;Point&gt;(); 可以通过移动语义转移所有权 shared_ptr.cpp 有关智能指针类型 shared_ptr 使用 需要 &lt;memory&gt; 头文件 可以有多个 shared_ptr 指针指向同一个对象 初始化 12//利用make_shared&lt;&gt;()方法初始化，调用的构造函数是&lt;&gt;类型的构造函数std::shared_ptr&lt;Point&gt; u = std::make_shared&lt;Point&gt;(); 通过 use_count() 方法可以得到有多少个指针指向同个对象 可以通过移动语义转移所有权 mutex.cpp 有关互斥锁 同步原语（Synchronization Primitives）是用于支持此多线程环境下线程同步的工具和机制。这些源于主要用于管理线程之间对共享资源的访问，防止数据竞争和保证线程安全 std::mutex 提供独占锁，确保同一时间只有一个线程可以获得互斥量，不可复制，不可移动 互斥量状态： 解锁状态意味着共享资源可用 加锁状态意味着共享资源不可用 需要 &lt;mutex&gt; 和 &lt;thread&gt; 头文件 lock() 锁住互斥量，unlock() 解锁互斥量，try_lock() 尝试锁住互斥量 被阻塞 References： C++多线程——互斥量mutex scoped_lock.cpp 有关多个互斥量的管理 需要 &lt;mutex&gt; 和 &lt;thread&gt; 头文件 当创建一个 std::scoped_lock 对象时，它尝试取得其所给互斥量的所有权。当控制权离开创建 scoped_lock 对象的作用域时，scoped_lock 会被析构，互斥量随之被释放。如果给定了多个互斥量，将使用避免死锁的算法，类似于 std::lock 是一个 RAII 风格的类 scoped_lock 类不可复制，不可移动 References： 【C++ 17 新特性 互斥锁】std::scoped_lock 的使用，管理多个互斥量 condition_variable.cpp 有关条件变量 需要 &lt;condition_variable&gt; 头文件 功能： 拥有条件变量的线程获取互斥量 循环检查某个条件，如果条件不满足则阻塞直到满足；如果满足则向下执行 某个线程满足条件执行完之后调用 notify_one 或 notify_all 唤醒一个或所有等待线程 wait() 第一个参数必须用 unique_lock unique_lock 不能复制，可以移动 References： C++11条件变量condition_variable详解 【C++】独占互斥锁（unique_lock） rwlock.cpp 有关读写器锁的用法 用 std::shared_mutex、std::shared_lock 和 std::unique_lock 需要 &lt;shared_mutex&gt; std::mutex 和 std::shared_mutex 的区别： std::mutex 提供独占访问，同一时间只能有一个线程持有该类型的锁 std::shared_mutex 提供共享访问和独占访问，允许多个线程通过持有 std::shared_lock 共享锁来只读访问，允许一个线程持有 std::unique_lock 独占锁来进行写操作，但是共享锁和独占锁不能同时存在，互斥 std::shared_mutex 更适用于读多写少的场景 s24_my_ptr.cpp 实现了一个 std::unique_pointer&lt;T&gt; 类 使用原始指针类型，很可能会出现内存泄露，二次释放，释放后访问的问题 RAII 的好处 smart_generator&lt;int&gt;() 和 dumb_generator&lt;int&gt;() 的区别 HyperLogLog 算法","link":"/2024/12/09/CMU15445-learning-note/"},{"title":"四级作文备考","text":"写在前面：没什么好写的，就是复习作文素材 ep1 Mobile Games ​ Nowadays mobile phones have become an inseparable social networking tool for college students,which results in the popularity of mobile games.Evidently,they exert a profound impact on the life of comtemporary college students. ​ Admittedly,playing mobile games is a good way to relieve stress and anxiety.Interactive entertainment provides tangible benefits,such as hand-eye coordination,the increase in brain's activity and the boost in creativity.Also,competitve games can improve participants' team-building skills,which are essential to their academic cooperation. ​ However,playing mobile games also has negative impacts on many college students.Some would become easily addicted to mobile games due to lack of self-control.Staring at mobile screens for many hours would lead to a sedentary lifestyle,causing eyestrain or headaches.Besides,too much exposure to violent languages and scenes will likely make college students more aggressive. ​ In all,mobile games should be used in a rational way,and college students should maximize their benefits to achieve bigger success in their future life. ep2 Online Shopping ​ Buying and selling online has become important parts of many people's lives.Consumers have embraced online shopping as a cheaper and more convenient way to buy what they want.However,the fact that shopping online is not really a cheap way cannot be neglected. ​ Attracted by discount coupons or other types of overwhelming promotions,consumers tend to overspend online.Sadly,a large proportion of those items they have bought online are later found unnecessary or useless.Once consumers want to return those items,they may be required to pay a return fee.Consumers also face losses on products like fruits and vegetables,which are very unlikely to be kept 100% fresh during transportation.Moreover,to achieve higher sales,unscrupulous businesses may display misleading,exaggerated and fraudulent information,leading to a higher risk of fraud and a huge loss of money for consumers. ​ Therefore,to enjoy a truly lower price of online products,we should go through websites carefully,and think twice before we choose to pay for the products.","link":"/2023/08/08/English-articles/"},{"title":"【GDCPC2023】Base Station Construction","text":"写在前面：没什么好写的 1 题意 给出一个长度为 的序列 以及 个区间 ，在其中选择若干个数，使得满足在每个区间 中至少有一个选择的数，求满足条件的选择的数的最小值 2 题解 首先可以证明，两个区间有覆盖关系时，我们可以只考虑小区间，舍去大区间，因为不管怎么样小区间里都会有被选的数，此时，大区间自然满足条件。 我们设 为考虑到第 个数且选第 个数的最小代价，设 为考虑到第 个数的最小代价。注意这里考虑到第 个数时，我们只满足完整的区间，位置 之后还有部分的区间暂时不算入，所以我们当遇到区间右端点才计算上这个区间的限制 可以写出状态转移方程： 于是就可以转移了，区间最小值可以无脑用线段树 掉，复杂度 3 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//头using namespace std;#define N 1000010#define int long longtemplate&lt;typename T&gt;inline void read(T &amp;x){ x=0;bool flg=0;char c=getchar(); for(;!isdigit(c);c=getchar()) if(c=='-') flg=1; for(;isdigit(c);c=getchar()) x=x*10+(c^48); if(flg) x=-x;}int n,m;int t;int a[N];int l[N];int g[N];int f[4*N];void pushup(int x){ f[x]=min(f[x&lt;&lt;1],f[x&lt;&lt;1|1]);}void build(int x,int l,int r){ if(l==r) return f[x]=0,void(); int mid=(l+r)&gt;&gt;1; build(x&lt;&lt;1,l,mid); build(x&lt;&lt;1|1,mid+1,r); pushup(x);}void change(int x,int l,int r,int o,int v){ if(l==r) return f[x]+=v,void(); int mid=(l+r)&gt;&gt;1; if(o&lt;=mid) change(x&lt;&lt;1,l,mid,o,v); else change(x&lt;&lt;1|1,mid+1,r,o,v); pushup(x);}int query(int x,int l,int r,int ql,int qr){ if(ql&lt;=l&amp;&amp;qr&gt;=r) return f[x]; int mid=(l+r)&gt;&gt;1,res=0x3f3f3f3f3f3f3f; if(ql&lt;=mid) res=min(res,query(x&lt;&lt;1,l,mid,ql,qr)); if(qr&gt;mid) res=min(res,query(x&lt;&lt;1|1,mid+1,r,ql,qr)); return res;}signed main(){ read(t); while(t--){ read(n); for(int i=1;i&lt;=n;i++) read(a[i]),g[i]=0,l[i]=0; read(m); for(int i=1;i&lt;=m;i++){ int a,b; read(a),read(b); if(!l[b]) l[b]=a; else l[b]=max(a,l[b]); } build(1,1,n); for(int i=1,j=0;i&lt;=n;i++){ change(1,1,n,i,g[i-1]+a[i]); if(l[i]&amp;&amp;l[i]&gt;j) g[i]=query(1,1,n,l[i],i),j=l[i]; else g[i]=g[i-1]; } cout&lt;&lt;g[n]&lt;&lt;endl; } return 0;}","link":"/2023/10/18/%5BGDCPC2023%5DBase-Station-Construction/"},{"title":"MySQL 学习笔记进阶篇","text":"数据库进阶学习 一、存储引擎 1. MySQL 体系结构 连接层 服务层 引擎层 存储层 2. 存储引擎 存储数据、建立索引、更新/查询数据 是基于表的，不是基于库的 也称为表类型 默认存储引擎： 查询当前数据库支持的存储引擎：SHOW ENGINES; 在创建表时，制定存储引擎：CREATE TABLE 表名(……) ENGINE = 存储引擎名 [COMMENT 表注释]; 3. InnoDB 高可靠性 高性能 特点： DML操作遵循ACID模型，支持事务 行级锁，提高并发访问性能 支持外键 FORRIGN KEY 约束，保证数据的完整性和正确性 文件：xxx.idb 称为表空间文件，存储表结构信息、数据和索引，二进制文件，cmd中使用 idb2sdi 命令查看 ​ 参数 innodb_file_per_table 表示每张表对应一个表空间文件 逻辑存储结构： 表空间：TableSpace 段：Segment 区：Extent（1M） 页：Page（16K） 行：Row 4. MyISAM 早期默认存储引擎 特点： 不支持事务，不支持外键 支持表锁，不支持行锁 访问速度快 文件： xxx.sdi 存储表结构信息 xxx.MYD 存储数据 xxx.MYI 存储索引 5. Memory 存储在内存中的，受到硬件问题，或断电问题影响，只能将这些表作为临时表或缓存使用 特点： 内存存放 hash索引（默认） 文件：xxx.sdi 存储表结构信息 6. 存储引擎选择 InnoDB：对事务的完整性有比较高的要求，在并发条件下要求数据的一致性。数据操作有插入查询还有更新删除 MyISAM：数据操作主要是插入查询，很少更新删除，对事务完整性、并发性要求不高 Memory：访问速度快，用于临时表及缓存 二、索引 帮助 高效获取数据的数据结构（有序） 优点：提高数据检索的效率，降低数据库的IO成本；通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗 缺点：索引列也要占用空间；降低更新表的速度 1. 索引结构 一般是B+树索引 B-Tree 多路平衡查找树 若最大度数为 ，每个节点最多存 个 ， 个指针 B+Tree 对比 所有数据出现在叶子结点 叶子结点形成一个单向链表 优势：相对于二叉树，层级更少，搜索效率高；对于 ，叶子结点和非叶子结点都会保存数据，导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；对于 索引，支持范围匹配和排序 hash 求 函数值，按值插入槽位 不支持范围查询 2. 索引分类 在 InnoDB 中，根据索引的存储形式，又分为以下两种： 聚集索引(Clustered Index)：将数据存储与索引放到了一块，索引结构的叶子结点保存了行数据，必须有而且只能有一个 二级索引(Secondary Index)：将数据与索引分开存储，索引结构的叶子结点关联的是对应的主键，可以有多个 聚集索引选取规则： 如果存在主键，主键索引就是聚集索引 如果不存在主键，将使用第一个唯一索引作为聚集索引 如果表没有主键，或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引 3. 索引语法 创建索引：CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name,...); 查看索引：SHOW INDEX FROM table_name; 删除索引：DROP INDEX index_name ON table_name; 4. SQL性能分析 SQL执行频率 客户端连接成功后，通过 SHOW [SESSION|GLOBAL] STATUS 命令可以提供服务器状态信息。 查看当前数据库的 INSERT、UPDATE、DELETE、SELECT 的访问频次：SHOW GLOBAL STATUS LIKE 'Com_______' 慢查询日志 慢查询日志记录了所有执行时间超过指定参数（ ，单位：秒，默认 秒）的所有SQL语句的日志。 查看慢查询日志是否开启：SHOW VARIABLES LIKE 'slow_query_log'; MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息： 1234# 开启MySQL慢查询日志开关slow_query_log=1# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志long_query_time=2 profile详情 profile能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过 have_profiling 参数，能够看到当前MySQL是否支持profile操作：SELECT @@have_profiling; 默认profiling是关闭的，可以通过set语句在session/global级别开启profiling：SET profiling = 1; 执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时： 12345678# 查看每一条SQL的耗时基本情况show profiles;# 查看指定query_id的SQL语句各个阶段的耗时情况show profile for query query_id;# 查看指定query_id的SQL语句CPU的使用情况show profile cpu for query query_id; #### explain执行计划 explain或desc命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接盒连接的顺序。 12# 直接在SELECT语句之前加上关键字EXPLAIN/DESCEXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件; 字段含义： id：select查询的序列号，表示查询中执行select字句或者是操作表的顺序（id相同，执行顺序从上到下；id不同，值越大，越先执行）。 select_type：表示select的类型，常见的取值有SIMPLE（简单表，即不使用表连接或子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等。 type：表示链接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all。 possible_key：显示可能应用在这张表上的索引，一个或多个。 key：实际使用的索引，如果为NULL，则没有使用索引。 key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。 rows：MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。 filtered：表示返回结果的行数占所需读取行数的百分比，filtered的值越大越好。 5. 索引使用规则 最左前缀法则 如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列，如果跳跃某一列，索引将部分失效（后面的字段索引失效）。 范围查询 联合索引中，出现范围查询（&lt;、&gt;），范围查询右侧的列索引失效。 索引列运算 在索引列上进行运算操作，索引将失效。 字符串不加引号 字符串类型字段使用时，不加引号，索引会失效。 模糊查询 如果仅仅是尾部模糊匹配，索引不会失效，如果是头部模糊匹配，索引失效。 Or连接条件 用or分隔开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引后不会被用到。","link":"/2024/12/04/Mysql-learning-2/"},{"title":"更好的终端模组","text":"改善 MacOS Terminal 的外观以及实用性，主要贴出来一些 References 用 Wezterm 代替 Terminal 1brew install wezterm 在 ~/.config/wezterm/wezterm.lua 里配置 配置文档：Link B站上搬运的教程：Link 暂时配成这样，不太愿意加图： 1234567891011121314151617181920212223242526272829303132local wezterm = require(\"wezterm\")config = wezterm.config_builder()config = { automatically_reload_config = true, enable_tab_bar = false, window_close_confirmation = \"NeverPrompt\", window_decorations = \"RESIZE\", default_cursor_style = \"BlinkingBar\", color_scheme = \"Nord (Gogh)\", font = wezterm.font(\"Fira Code\", { weight = \"Bold\" }), font_size = 15, background = { { source = { Color = \"#282c35\", }, width = \"100%\", height = \"100%\", opacity = 0.85, }, }, window_padding = { left = 30, right = 30, top = 30, bottom = 30, },}return config image-20241227194724776 等寒假有时间了设计一下 添加了代码高亮和代码补全的插件，b站视频有讲，需要在 .zshrc 里配置： 1234567source $(brew --prefix)/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh(( ${+ZSH_HIGHLIGHT_STYLES} )) || typeset -A ZSH_HIGHLIGHT_STYLESZSH_HIGHLIGHT_STYLES[path]=noneZSH_HIGHLIGHT_STYLES[path_prefix]=nonesource $(brew --prefix)/share/zsh-autosuggestions/zsh-autosuggestions.zsh wezterm 的上下分屏：Ctrl + Option + % wezterm 的左右分屏：Ctrl + Option + \" 光标切屏：Ctrl + Shift + 方向键 一般就使用 tmux 的分屏比较好，上面的难记 用 Neovim 搭建 PDE 费老劲学 vim，还得练 1brew install nvim 有图形化界面，还不错，外观还需要配置 参考：Link 上下分屏：split 左右分屏：vs 光标切屏：Ctrl + h j k l 添加插件 参考：Link thefuck 一个可以帮你修改打错的命令的插件，一旦你打错了一个命令，你就可以接着一句 fuck，它就会自己帮你改对 在 .zshrc 中配置（alias可以改别名）： 12eval $(thefuck --alias)eval $(thefuck --alias fk) eza 更好的 ls，在 .zshrc 文件中配置（用 eza 替换 ls）： 1alias ls=\"eza --color=always --long --git --no-filesize --icons=always --no-time --no-user --no-permissions\" tldr 告诉你这个关键字有一些什么有趣有用的用法 zoxide 更好的 cd，在 .zshrc 文件中配置： 1eval \"$(zoxide init zsh)\" 会记住你进过的文件夹，再进就不用一个一个 cd 了，如果有多个满足条件，空格 + Tab 选文件夹 powerlevel10k 一个终端主题，蛮好看 用 tmux 管理多个 Terminal 参考：Link 配置文件（~/.tmux.conf）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546set -g default-terminal \"screen-256color\"set -g prefix C-aunbind C-bbind-key C-a send-prefixunbind %bind | split-window -hunbind '\"'bind - split-window -vunbind rbind r source-file ~/.tmux.confbind -r j resize-pane -D 5bind -r k resize-pane -U 5bind -r l resize-pane -R 5bind -r h resize-pane -L 5bind -r m resize-pane -Zset -g mouse onset-window-option -g mode-keys vibind-key -T copy-mode-vi 'v' send -X begin-selectionbind-key -T copy-mode-vi 'y' send -X copy-selectionunbind -T copy-mode-vi MouseDragEnd1Pane# tpm pluginset -g @plugin 'tmux-plugins/tpm'# list of tmux pluginsset -g @plugin 'christoomey/vim-tmux-navigator'set -g @plugin 'jimeh/tmux-themepack'set -g @plugin 'tmux-plugins/tmux-resurrect'set -g @plugin 'tmux-plugins/tmux-continuum'set -g @themepack 'powerline/default/cyan'set -g @resurrect-capture-pane-contents 'on'set -g @continuum-restore 'on'run '~/.tmux/plugins/tpm/tpm' 快捷键： 魔法前摇：Ctrl + a 上下分屏：- 左右分屏：| 光标切屏：Ctrl + h j k l 配置更新：r 改变分屏大小：h j k l 分屏窗口最大化/最小化：m vi 风格移动光标和页面 安装插件：I 新建窗口：c 切换窗口：窗口代号 窗口重命名：, 切换到相邻窗口：p n 窗口及终端信息：w 退出复制模式：Ctrl + C","link":"/2024/12/27/better-terminal/"},{"title":"瞎做到的好题","text":"写在前面：随便刷到的好题 ABC288D 有差分和剩余系的思想，但是不用真的差分，把整个序列按 分类，会发现，每次只改变每一类数中的一个，所以要想把所有数消成 ，只需要区间内每类数之和相等即可，挨个消，消到最后，一定可以整成 这种形式 P9753 跟括号匹配一点都不一样 首先要找两个相邻且相同的字符，然后才能往外消，不妨设 为第 个字符往后最小的 ，使 可被消除，然后 表示从第 个字符跳多少段最小可消除段才能到不能跳为止，答案就是 至于 转移，需要只需要再记录一个 表示从 开始跳可消除段，跳到 这个字符的所在下标，倒序遍历就行了 P5369 数据范围可以看出来是状压 考虑最大前缀和有什么性质，假设从 加到 为最大前缀和（ 为满足条件的最大 ） ： 在 区间内，所有的后缀和都 ，除了整体，整体可以 ，因为必须要算上一个数 在 区间内 ，所有的前缀和都 所以对于每个状态 ，我们记录用全集合内的元素可以满足 1. 的方案数 以及可以满足 2. 的方案数 对于 的特殊情况，我们可以多开一维 ，记录是否整体 关于转移，用向外转移，即 就不会漏辣 2022ICPC_Nanjing_D 乐子题，打表看出来最后一定会成为一个不变的序列，只有第一个数与别的数不同，是其他数的两倍，那个 可以看成无限次 2022CCPC_Guangzhou_H 直接想嘛，记录每个序列里没有的数的奇偶性，A一定填奇数更优，B一定填偶数更优，直接模拟 2022ICPC_Jinan_E 每次滑动进出的元素奇偶性相同，考虑根据奇偶性一定相同的元素分块，有 个大小为 的块，有 个大小为 的块，解 这个方程，用exgcd求出一个特殊解 好了，然后通解就是 ，根据限制分别求出来 的取值范围，看看有无交集 是个小nb题 代码放这了 1234567891011121314151617181920212223242526272829303132333435363738//头文件int t;int n,k,p,q;int exgcd(int &amp;x,int &amp;y,int a,int b){ if(b==0){x=1,y=0;return a;} int g=exgcd(y,x,b,a%b); y-=(a/b)*x; return g;}int main(){ read(t); while(t--){ read(n),read(k); int a,b,x,y; a=n/k+1,b=n/k; p=n%k,q=k-p; int g=exgcd(x,y,a,b); if((n/2)%g!=0){cout&lt;&lt;\"No\"&lt;&lt;endl;continue;} x*=(n/2)/g; y*=(n/2)/g; int l1=-x/b,l2=(y-q)/a; if(l1*b+x&lt;0) l1++; if(y-l2*a&gt;q) l2++; int r1=(p-x)/b,r2=y/a; if(r1*b+x&gt;p) r1--; if(y-r2*a&lt;0) r2--; if(max(l1,l2)&lt;=min(r1,r2)) cout&lt;&lt;\"Yes\"&lt;&lt;endl; else cout&lt;&lt;\"No\"&lt;&lt;endl; } return 0;} 2022CCPC_Mianyang_G 纯模拟，但是有意思的地方在于对时间复杂度的预测，为什么暴力能过，因为在一个 的排列里面，极值最多只可能有 个，所以模拟最劣复杂度为","link":"/2023/10/13/good-problem/"},{"title":"数学建模——数据预处理","text":"写在前面：好久没更新博客了，不知道因为什么原因，考试周快过去了，插空更一个队长分享的一个课程的总结。 边听课边写线代卷子，听了个大概，主要讲的是针对大数据题做的数据预处理专题，深有体会，经过数理大赛和亚太杯的胡乱搞，感觉前期的数据预处理过程和结果对后期的建模确实有比较重要的影响，故想写一些东西加深印象。 数据预处理一般包括：数据集成、数据规约、数据清洗、数据变换，下面挨个来说 数据集成 数据集成一般指把来自不同数据源、用不同表示规则表示的数据整合为同一类型、统一表示规则的数据方便处理。 实体识别问题 就比如说最近一次的亚太赛的 题，要求对图片中苹果的个数、位置、重量、成熟程度进行识别，当时我们使用的方法是基于数连通块个数的方法再进行优化，采用的数据集成方法就是分别读取图片中每个像素点的 值，然后整合到一个表格中，再进行下一步。 实体识别问题再提一嘴，可以使用 labelimg 来对图片进行标注框画，建模一般使用深度学习模型 数据字段问题 刚好对应数理大赛的赛题，房价预测模型，房子的属性参数不止有数值型数据，还有非数值型数据比如字符串数据，如果该标签为分类变量，我们当时处理成了 变量数据，大大增加了标签数量，非分类变量一般与房价关联程度不高，直接删去该标签 冗余和相关性分析 如果一个标签能够通过其他标签推出或表示，即相关程度大，那么这个标签就是冗余数据。判断冗余数据可以使用相关性分析。 皮尔逊相关性分析 斯皮尔曼相关性分析 元组重复","link":"/2023/12/24/modeling-prework/"},{"title":"你不是第一次当新生了，应该知道怎么做了吧","text":"开学了，写点东西 day -2 大姨带着元宝来送我上火车，元宝一见到我就抱住我说：“哥哥你什么时候才回来看我啊”，真的佩服小孩子的记性，明明上了高中以后就没再见过一面了，却还是和我亲的不行 在火车站坐着，大姨让我看着元宝，却带回来一袋子麦当劳，让我上车吃，姥姥的饺子还在保温杯里，大姨说容易坏，上车先把麦当劳吃了吧，然后我就在车上吧饺子和汉堡全吃了，撑得睡不着觉 btw 退役军人证是真的爽，人们排了好长的队，但是直接从队首进到站台了 上车以后看了两集生活大爆炸就睡了，防止手机没电一直开着超级省电 day -1 早晨七点起的，好像到湖南了，早饭吃了碗泡面就回卧铺上躺着了，还做成了一项伟业：把五个箱子袋子缩减到了四个 南方的山和水比北方多多了，一会儿进一个隧道，一会儿跨一条湖，我坐在窗户前面看了一个多小时，好像被吸引住了，可能也是无聊 中午12点到广州了，和我爸我妈会和，也是这个时候知道会有台风，辅导员说可以提前入住，然后我们就直接去华工了，先坐的 号线，从广州北站到高增，再倒 号线，从高增坐到汉溪长隆，最后倒 号线，到终点站大学城南，不知道为什么，去一座城市，我就特别想坐一下，这个城市的地铁，就就就特别喜欢underground（北京地铁 号线四惠前面的那段 在志愿者的指引和导航的支持下找到了 ，打开宿舍门发现 已经到了，我才想起来 是临干，简单认识了一下就开始收拾东西了，收拾了一下午，把蚊帐弄好了就溜了，晚上住的酒店还不错 但是，酒店没有热水，我斗胆洗了发凉水澡，成功把自己弄感冒了，鼻子堵了，打喷嚏打个不停，没办法，还是睡了，睡前看到明天下午 点以后让准备好吃的和用的，要停工停业，给我吓一哆嗦，但鼻子还是堵的，难受 day 0 早晨六点，被一口气憋醒，然后就睡不着了，于是起来吃早饭，发现这里的店真的是开门好晚，七点都没几家点开门，吃了口上海小笼包就赶到学校了，继续收拾东西 收拾了一上午以后看看还缺垃圾桶、盆等大件的生活用品，看到这里便利店真的卖的有点点小贵，在学校食堂吃了第一顿饭后，我们就打车到了最近的沃尔玛，说最近也不近，打车都花了四十多，后来一想，感觉还不如在学校买呢，打车都贵的要死 下了车，不知道为啥感觉走不动道，累的不行，头也晕，有点烧，我妈觉得我又阳了，我也觉得，硬撑着买完了一些东西，打车回酒店睡了一下午，路上买了些药，吃了，好点，但不多 晚上开始下雨了，是台风吗，可能是吧，说是 号凌晨离我所在地最近，也不管啦，反正也病着，出不去 家长回去的火车停运了，找了半天候补票，最后还是没订上 day 1 今天报道，下着雨，吃了顿广东早茶就打车去华工了，收拾东西，线上报个到，去交个户口迁移证，该弄的都弄了 发现病情有点改善 我说，就在宿舍待着吧，他们说，订上票了 看到 在看闫总的课，突然想起来高一的时候自己听闫总的课，觉得这怎么可能是从我们学校出来的，我怎么没学成这样， 就退役的小 b 崽汁斗胆挑战 ，看后续吧 跟 聊了会儿天，感觉是个大佬，作息规律，还学的多，感觉卷不过的样子 /qq 跟 渗透了一下想当学习委员的意愿 晚上 买的洗衣机到了，只有我和 在宿舍，我们没管快递师傅带个推车的建议，空着手去了，然后抬着大洗衣机，从天桥底下走到宿舍底下，然后又搬上四楼，搬的满头大汗，得，病是完全好了 在宿舍待的第一个晚上，我就知道了山东有多卷，反正比河北卷 day 2 快七点起的，洗漱完， 带我去见另外几个临干和他们的室友，先见到 和 ，然后在食堂见到了 和 ，和他们一块吃早饭，我要的煎饼，感觉和北方的做法不太一样，吃起来也还行，我们因为拿体检表晚来了点所以只是安静的吃（社恐 估计是他们都提前见过了，对我还比较陌生，被 问叫什么，好像又被认错名字里的字了，果然是个易错字，高中老师每人念错一遍的威力 然后在黄老师的带领下逛了一圈校园，知道路怎么走啦，学校还是蛮大的嘛（赞赏 然后去体育馆体检了，体育馆的屋顶好像某处遗址的材质，不是很懂 去和家长告别，在正门拍了几张照片，在 ❤️ 那里拍了几张，最后吃一顿饭就回浙江了，我也带着点东西回宿舍了 回到宿舍， 又要去当志愿者，于是就我一个人了，和 视频了会，聊挺开心，回来 就告诉我他也想当学习委员，好像有点棘手，我确实胜算不太大，戴耳机，听歌，洗衣服，晾上， 来啦，帮他搬东西去，然后吃晚饭 晚上自己骑着小蓝去 新天地了，人蛮多，蛮繁华，戴着耳机，人声听不到了，只有音乐声，找点好位置拍点照，看着，走着，突然发现自己是只有自己在这座城市上了，还好吧，有点说不出的感觉 骑着车子姥姥给我打电话，第一个没接到，我说自己在洗衣服，我要是说我自己在外面逛，肯定又要被担心被拐走了 感觉黄老师确实蟀 day 3 报道第三天，早晨吃饭带上 了， 又认了一下，吃完去拿快递回宿舍了 我跟 说我改成科创委员吧，我还是蛮好说话的（自豪 下午我想出去玩，问他们去不去，然后就都去了，去的北京路，坐了一个小时地铁，到了一个比较古老又繁华的道路上，左边是古老的破旧不堪的建筑，残留着上个世纪的遗韵，右边是大商场，展示着繁华大都市的脸面，稍微转了转，在这里可以看到无轨电车，相当于公交，但是上面连着线，第一次见，新鲜事物 去吃冰，点了个里面有芒果和奶皮的甜品还有抹茶味的（应该是）冰沙，做的好高，分量挺足，就是吃完容易窜，就像 一样 然后我们去大沙头游船码头坐船去啦，一个人 块钱，还可以，主要是江风太好吹了，感觉一切不好的事都能被它吹走，然后只留下享受，大桥从头顶上略过，广州塔从身旁游过，想用无人机拍下来这样的景象 船上有专门的摄影师，先给你拍照，然后给你洗出来装上纸质相框，问你要三十块拿走，最后我们自己在船上拍了一张，能体会一次就不错 今天最后一位同仁 来了， 宿舍齐活，直接启动！ day 4 因为明天要考试了，所以打算复习复习，上午听了个四级听力，错了 个，再听一个，听不下去了，听不懂，然后开始写阅读，错了 个，不写了 拿快递，然后拿快递，然后更新桌面，二阶段宿舍改造计划启动 晚上有学生会招新，去听了听，看中了三个：外联部、宣传部、学术科技部，最后报了外联和宣传 试了下收音机，金属味有点重 day 5 早晨吃完饭去照片采集，碰到 ， 看了看考场，回宿舍歇着了 看了看单词，还是有点不放心收音效果，就没带收音机（惊（不是故意的（带了个空盒子（以为带上了，慌得我直接找旁边刚考完的人借了个，最后还没用到 在 门口看到了 力（喜 中午吃的意面，不好吃，差评 取快递，三阶段宿舍改造计划启动 晚上开学典礼，去食堂感觉不想吃，就买了瓶可乐去音乐厅后面的座位上歇着了，看 说编程领域 的使用率还是比较高的，瞬间舒心 听课听的很认真，有被教育到了，要好好学习咯，睡觉啦 /dy day 6 下了一天雨，在宿舍待了一整天，中午饭晚上饭都在宿舍吃零食，根本不想出宿舍 上午敲了一上午代码，打了会音游，下午睡到 点半，起来梦了会游，去面试外联部了，口才不太好，想到的都没说出来，感觉不是太妙 晚上说是有集会但是大雨倾盆，逃了 到床上打 找手感，切了 道，感觉良好 day 7 依然在下雨，上午是班级破冰活动，早上准备去，拿上新买的雨伞，但是发现坏了，我才用了一次啊 /dk，结果在楼下买了个高达 元的雨伞，早饭都没吃就去了 时间好像只有一个半小时，比较紧，让所有人简单介绍了下自己，然后又让班委竞选了一下（然而每个班委只有一个人竞选）没尬住，大胜利 搞完去拿快递，发现都不知道自己取了哪个没取哪个，取了个寂寞，回来就在遇见小面找了个座位吃了 块钱的软骨丸子汤面、羊肉串还有冰粉，还不错，就是有点贵 回到宿舍发现自己耳机进水了一样，一直有电流声，md我快两百块钱买的啊，怎么这么不经用 下午干正事 晚上听詹书记教育我们，感觉讲课跟 一样抽象，喜欢举例子，喜欢说看似废话的话，意识流式讲话，原来有学识的人都是这么讲话，爱了爱了 day 8 今天上午是全校的开学典礼，下午是全校的新生安全教育，一散会就被叫去搬书了，分完书回宿舍写作业，写到半夜才写完 day 9 今天早晨起晚了，赶忙去七楼面试宣传部，平稳地完成了，晚上告诉我通过了 yeah 打算出去玩，简单找了找资料，首先先去坐了有轨电车，从万胜围到广州塔，发现那里有步行桥可以跨珠江，觉得傍晚来风景最好，就预约了六点到七点的时间，然后坐 线去广州图书馆和广州博物馆，座位和大厅是没有隔离连着的，感觉人多的话工作看书会有点吵，逛了一圈出来想去博物馆，发现需要预约并且当天已经预约满了，就只能换个地方去了，去了旁边的 艺术购物中心，上流人士的游览场所，有钢琴表演，金碧辉煌，我这种土狗逛了逛就溜了，溜去彩虹桥旁边的西华路吃小吃，彩虹桥确实是个很魔幻的地铁站，非常大，天花板上装饰着彩虹，西华路上人一般多，只有那么几家网红店门口排着长队，剩下的店里都看不到顾客，我点了一份煎饺还有一杯杨枝甘露，还是蛮好吃的，回图书馆看了会书，就去广州塔的步行桥上欣赏日落了，但是太阳看不见一点，扫兴地去五山校区听华南虎宣讲会了，看到好多名人，抽奖还中奖了（喜，想加入，但是再看看吧 明天就开课了，新生记录就先这样完结吧，先让我学学怎么学习大学的知识……","link":"/2023/09/06/new-student/"},{"title":"牛客挑战赛48C","text":"就非得写点东西吗 题意 个点，连 条边，形成 棵树，每种方案贡献为这 棵树大小之积，求所有方案贡献和 题解 根据题意，这 棵树肯定为无根树 首先考虑要生成一棵 结点无根树，根据 序列，可以很轻松地求出方案数，如果算上每个方案的贡献，直接 就好了，答案是 发现这跟构造有根树的方案数一样，所以我们可以做一个题意转换，我们令每种方案里确定每棵树的根节点，那么方案数就跟贡献和一样了 我们假设一个虚点 ，令它连接每棵树的根节点，现在就可以算了 一共有 个点， 序列长度为 ，其中点 的度是知道的，有 ，所以在 序列中， 应该出现 次，先选 ，然后剩下的数都是在 ，再 就是答案 答案是 ，时间复杂度 代码 12345678910111213141516171819202122232425#define int long longconst int Mod=1e9+7;int n,m;int ans=1;int fpow(int a,int b){ int res=1; for(;b;b&gt;&gt;=1,a=a*a%Mod) if(b&amp;1) res=res*a%Mod; return res%Mod;}signed main(){ read(n),read(m); for(int i=1;i&lt;=m;i++) (ans*=i)%=Mod; ans=fpow(ans,Mod-2); (ans*=fpow(n,m))%=Mod; for(int i=n-m;i&lt;=n-1;i++) (ans*=i)%=Mod; cout&lt;&lt;ans&lt;&lt;endl; return 0;}","link":"/2023/10/18/newcoder48C/"},{"title":"有关完全图中生成树数量问题的思考","text":"写在前面：在复健矩阵的时候发现了 [NOI2007]生成树计数 这个题，遂起兴研究生成树计数 个结点的环的生成树个数为 个结点的完全图的生成树个数为 第一句话很好理解，只要去除环中的任意一条边，就是一棵生成树 第二句话也叫 公式，证明需要用到 序列的东西，顺便提一嘴， 序列就是为证明 公式而诞生的 犹记两年前 讲题时给我们讲到过这个东西，但是已经忘掉了 Prufer Code 以下提到的树都是有标号无根树 每棵结点数大于 的树都对应唯一一个 序列，每个 序列也唯一对应一棵结点数大于 的树，两者为双射关系 由树构造 序列步骤如下： 找到叶子结点中编号最小的，记作 ，将 的父结点 加入序列 删去 结点 重复步骤 1. 和 2. ，直到整棵树只剩下两个结点，结束 显然，若整棵树有 个结点，那么该树对应的 序列长度应该为 由构造过程，可以得出两个结论： 结点 最后一定没有被删除 每个结点的度是序列中该结点出现次数 根据构造过程，相似地，可以得出由 序列构造树的方法： 根据度数为 确定当前的叶子结点，找出叶子结点中编号最小的结点，记作 ，将 的父结点设为序列中第一个没有遍历过的结点 删去 ， 度数 ，如果 度数为 ，那么把其加入叶子节点集合中 重复 1. 和 2. ，最后会剩下两个叶子结点，将其连接，结束 由每一步构造的唯一性以及每一步反构造的唯一性，由反证法可以得出 不存在两个 序列对应同一棵树 不存在两棵树对应同一个 序列 设 为所有树构成的集合， 为所有 序列构成的集合，由 1. 得 ，由 2. 得 ，即 ，得证 若要钦定根，最后可以添加一个根节点，序列长度变为 ，相似地，可以唯一确定一棵有标号有根树 更好的构造与反构造方法 模板 用代码模拟构造和反构造当然可以用小根堆，时间复杂度 还有一种更为快速的方法 构造： 找到编号最小的叶子结点 ，父结点 加入序列 若删去 后， 变为叶子结点，且编号比 小，则 为当前编号最小的叶子结点，直接令 为 ，重复操作 1. 和 2. 若不满足 2. ，将 自增，直到找到下一个未删除的叶子结点 最多自增 次，时间复杂度 12345678910111213141516int p;for(int i=1;i&lt;=n;i++) if(d[i]==1){p=i;break;}vector&lt;int&gt; prufer;int l=p;while(prufer.size()&lt;n-2){ int f=fa[l]; prufer.push_back(f); d[f]--; if(d[f]==1&amp;&amp;f&lt;p) l=f; else{ p++; while(d[p]!=1) p++; l=p; }} 反构造：同上 看代码 12345678910111213141516int p;for(int i=1;i&lt;=n;i++) if(d[i]==1){p=i;break;}int l=p;for(int i=1;i&lt;=n-2;i++){ int f; f=fa[l]=prufer[i]; d[f]--; if(d[f]==1&amp;&amp;f&lt;p) l=f; else{ p++; while(d[p]!=1) p++; l=p; }}fa[l]=n;//最后剩下的两个点 OK 学完 序列后就能证明 公式了，由于每个序列唯一对应一棵树，那么长度为 的序列的总个数就是 个点的完全图的生成树个数，也就是 个 有根树对应 序列长度为 ，数量为 个 来点数学 如果给定 并固定每个点的度数，那么能形成的有标号无根树有多少？ 考虑 序列，先阶乘再去重就好啦，设第 个点度数为 ，答案是 板子 完全二分图生成树个数？ 左部点 个，右部点 个 构造 序列最后剩下的两个点一定是左部点一个右部点一个，考虑删去的点，删去一个左部点一定会往序列填一个右部点，删去一个右部点一定会往序列填一个左部点，最后的序列中左部点的数量为 个，右部点数量为 个， 序列共有 个，答案也是这个 以上 都需要特判o 当时找了几道题，我去做做 CF917D（这道题也是曾经 佬课件上的一道题）但是我不会二项式反演 ARC106F（需要生成函数，不会捏） 牛客挑战赛48C（这个可以写） TopCoder SRM697 div1 hard 是这道 （看不懂所以不写） 把一些参考放在这里 《Tree-structured Data Regeneration with Network Coding in Distributed Storage Systems》 【朝夕的ACM笔记】图论-Prufer序列 - 知乎 (zhihu.com) Prufer 序列 - Achtoria - 博客园 (cnblogs.com)","link":"/2023/10/17/number-of-STs-on-CG/"},{"title":"练一些分治题","text":"写在前面：分治这个东西好像容易被大家忘记，专门找一些题练练 Luogu P1429 分治基本思想，确定一个分割点，各自处理左右两部分答案，最后合并答案 先考虑一维，确定一个中间点，假设左右分别都求出来了最近点对，然后需要求整个部分的答案，需要考虑跨分界点的点对，设 为左右两边答案中小的那个，只需要考虑分界点左右距离为 内的点，至多有两个点，复杂度降到 二维一样，按其中一维像上面做之后，把另一维排序，取靠近分界点的点进行枚举，枚举也无须做到平方级别，每个点只需要尽可能枚举相近的点即可，可以证明点数不超过 个，复杂度降到 LOJ #6490 也是区间分成两半去考虑，当两边的答案处理好之后，需要考虑跨过 的区间 以左边为例，依次枚举左端点 ，求出跨 的长度在 的区间中最大的区间，具体用前缀和 + 表实现 查找，记录下来 再往后扫， 的答案就是 ， 一定是在 记录的最大区间里面的 右边同样，注意开要","link":"/2023/09/07/partition-problems/"},{"title":"MySQL 学习笔记基础篇","text":"数据库基础学习 一、MySQL 数据库的数据模型 用户登录访问 数据库，数据库下存放若干表，表中存储信息。 二、SQL 语法——通用 单行或多行书写，分号结尾； 可空格、缩进； 的 语句不区分大小写，关键字建议大写； 单行注释用 -- something 或 # something； 多行注释用 /* something */。 三、SQL 语法——DDL 全称 ，数据定义语言，用来定义数据库对象（数据库、表、字段）。 数据库-查询 查询所有数据库 SHOW DATABASES; 查询当前数据库 SELECT DATABASE(); 数据库-创建 CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]; 数据库-删除 DROP DATABASE [IF EXISTS] 数据库名; 数据库-使用 USE 数据库名; 表-查询 查询当前数据库所有表 SHOW TABLES; 查询表结构 DESC 表名; 查询指定表的建表语句 SHOW CREATE TABLE 表名; 表-创建 1234567CREATE TABLE 表名( 字段1 字段1类型 [COMMENT 字段1注释], 字段2 字段2类型 [COMMENT 字段2注释], 字段3 字段3类型 [COMMENT 字段3注释], ...... 字段n 字段n类型 [COMMENT 字段n注释]) [comment 表注释]; 表-修改 添加字段 ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束]; 修改数据类型 ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度); 修改字段名和字段类型 ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束]; 删除字段 ALTER TABLE 表名 DROP 字段名; 修改表名 ALTER TABLE 表名 RENAME TO 新表名; 表-删除 删除表 DROP TABLE [IF EXISTS] 表名; 删除指定表，并重新创建该表 TRUNCATE TABLE 表名; 补充： 的数据类型 数值类型 分类 类型 大小 有符号(SIGNED)范围 无符号(UNSIGNED)范围 数值类型 TINYINT 1 byte [-128,127] [0,255] SMALLINT 2 byte [-32768,32767] [0,65535] MEDIUMINT 3 byte [-8388608,8388607] [0,16777215] INT/INTEGER 4 byte [-2147483648,2147483647] [0,4294967295] BIGINT 8 byte [-263,263-1] [0,2^64-1] FLOAT 4 byte / / DOUBLE 8 byte / / DECIMAL / / 关于 类型定义时传入两个参数 ， 表示精度，有效位数， 表示标度，小数位数。 字符串类型 分类 类型 大小 描述 字符串类型 CHAR 0-255 bytes 定长字符串 VARCHAR 0-65535 bytes 变长字符串 TINYBLOB 0-255 bytes 不超过255个字符的二进制数据 TINYTEXT 0-255 bytes 短文本字符串 BLOB 0-65535 bytes 二进制形式的长文本数据 TEXT 0-65535 bytes 长文本数据 MEDIUMBLOB 0-16777215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16777215 bytes 中等长度文本数据 LONGBLOB 0-4294967295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4294967295 bytes 极大文本数据 后面传参是字符串长度 日期类型 分类 类型 大小 范围 格式 描述 日期类型 DATE 3 1000-01-01 至 9999-12-31 YYYY-MM-DD 日期值 TIME 3 -838:59:59 至 838:59:59 HH:MM:SS 时间值或持续时间 YEAR 1 1901 至 2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00 至 9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:01 至 2038-01-19 03:14:07 YYYY-MM-DD HH:MM:SS 混合日期和时间值，时间戳 四、SQL 语法——DML 全称 ，数据操作语言，用来对数据库表中的数据进行增删改。 添加数据 给指定字段添加数据 INSERT INTO 表名(字段名1, 字段名2, ...) VALUES(值1, 值2, ...); 给全部字段添加数据 INSERT INTO 表名 VALUE(值1, 值2, ...); 批量添加数据 INSERT INTO 表名(字段名1, 字段名2, ...) VALUE(值1, 值2, ...), (值1 值2, ...), (值1, 值2, ...); NSERT INTO 表名 VALUE(值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); 修改数据 UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [WHERE 条件]; 删除数据 DELETE FROM 表名 [WHERE 条件]; 五、SQL 语法——DQL 全称 ，数据查询语言，用来查询数据库中表的记录。 1234567891011121314SELECT [DISTINCT] 字段1 [AS 别名1], 字段2 [AS 别名2], 字段3 [AS 别名3], ...FROM 表名列表WHERE 条件列表GROUP BY 分组字段列表HAVING 分组后条件列表ORDER BY 字段1 ASC/DESC, 字段2 ASC/DESC;LIMIT 起始索引, 查询记录数; 补充：聚合函数 统计数量 count 最大值 max 最小值 min 平均值 avg 求和 sum 六、SQL 语法——DCL 全称 ，数据控制语言，用来创建数据库用户、控制数据库的访问权限。 管理用户 查询用户 USE mysql; SELECT * FROM user; 创建用户 CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 修改用户密码 ALTER USER '用户名'@'主机名' IDENTIFIED WITH caching_sha2_password BY '新密码'; 删除用户 DROP USER '用户名'@'主机名'; 权限控制 查询权限 SHOW GRANTS FOR '用户名'@'主机名'; 授予权限 GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名'; 撤销权限 REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名'; 七、函数 字符串函数 字符串拼接：CONCAT(S1,S2,...,Sn) 字符串转为小写：LOWER(str) 字符串转为大写：UPPER(str) 左填充：LPAD(str,n,pad) 右填充：RPAD(str,n,pad) 去字符串头尾空格：TRIM(str) 取子字符串：SUBSTRING(str,start,len) 数值函数 向上取整：CEIL(x) 向下取整：FLOOR(x) 取模：MOD(x) 0~1随机数：RAND() 四舍五入，保留小数：ROUND(x,y) 日期函数 当前日期：CURDATE() 当前时间：CURTIME() 当前日期和时间：NOW() 获取年份：YEAR(date) 获取月份：MONTH(date) 获取日期：DAY(date) 一个日期加上一个时间间隔：DATE_ADD(date,INTERVAL expr type) 两个时间之间的天数：DATEDIFF(date1,date2) 流程函数 IF(value,t,f) 为 ，返回 ，否则返回 IFNULL(value1,value2) 不为空输出 ，否则 CASE WHEN [val1] THEN [res1] ... ELSE [dafault] END 如果 为 ，返回 ，……，否则返回 默认值 CASE [expr] WHEN [val1] THEN [res1] ... ELSE [default] END 如果 的值等于 ，返回 ，……，否则返回 默认值 八、约束 约束是作用于表中字段上的规则，用于限制存储在表中的数据。 非空约束：限制该字段的数据不能为 ，关键字 NOT NULL 唯一约束：保证该字段的所有数据都是唯一、不重复的，关键字 UNIQUE 主键约束：主键是一行数据的唯一标识，要求非空且唯一，关键字 PRIMARY KEY，自增关键字 AUTO_INCREMENT 默认约束：保存数据时，如果未指定该字段的值，则采用默认值，关键字 DEFAULT 检查约束：保证字段值满足某一个条件，关键字 CHECK 外键约束：用来让两张表的数据之间建立连接，保证数据的一致性和完整性，关键字 FOREIGN KEY 外键约束语法： 12345CREATE TABLE 表名( 字段名 数据类型, ...... [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主表字段名)); 1ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表字段名); 外键删除/更新行为： NO ACTION：当在主表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新 RESTRICT：同上 CASCADE：当在主表中删除/更新对应记录时，首先检查该纪录是否有对应外键，如果有，则也删除/更新外键在子表中的记录 SET NULL：当在主表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为 （要求子表字段可以设置为 ） SET DEFAULT：主表有变更时，子表将外键列设置成一个默认的值（Innodb不支持） 1ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表字段名) ON UPDATE 关键字 ON DELETE 关键字; 九、多表查询 使用 SELECT * from A,B 查询出来的是 表和 表的笛卡尔积，需要 关键字提取需要的项，去除不需要的项 1. 内连接 内连接查询的是两张表交集的部分 隐式内连接 SELECT 字段列表 FROM 表1,表2 WHERE 条件…; 显式内连接 SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件…; 2. 外连接 左外连接包括左表所有数据，右外连接包括右表所有数据 左外连接 SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件…; 右外连接 SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件…; 3. 自连接 可外可内 SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件…; 4. 联合查询 把查询结果合并起来 123SELECT 字段列表 FROM 表A …UNION [ALL]SELECT 字段列表 FROM 表B …; UNION 去重 UNION ALL 不去重 5. 子查询 标量子查询 列子查询 行子查询 表子查询 十、事务 查看事务提交方式 SELECT @@autocommit; 设置事务提交方式（设置成不自动提交） SET @@autocommit = 0; 提交事务 COMMIT; 回滚事务 ROLLBACK; 事务四大特性（ACID） 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。 并发事务问题 脏读：一个事务读到另外一个事务还没有提交的数据。 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同。 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在。 事务隔离级别 Read uncommitted：三个并发事务问题都会出现 Read committed：解决了脏读，没有解决不可重复读和幻读 Repeatable Read(默认)：解决了脏读和不可重复读，没有解决幻读 Serializable：三个问题都解决了 查看事务隔离级别 SELECT @@TRANSACTION_ISOLATION; 设置事务隔离级别（SESSION 只管当前会话，GLOBAL 管全局） SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE};","link":"/2024/11/22/Mysql-learning-1/"},{"title":"最优化理论的三大非经典算法","text":"写在前面：要打数学建模，学点好玩的 模拟退火 是一个随机化算法 借鉴固体的退火过程 最核心的地方在于，对前一状态进行随机扰动，如果更优就作为当前状态，如果不优，有一定概率取为当前状态 局部最优的地方不一定全局最优，所以有一定概率从局部最优跳出，去寻找全局最优 参数有： T_begin : 初始温度 T_end : 结束温度 : 退火速率系数 T : 当前温度 以上是控制随机化过程中对状态的遍历程度完全/不完全，具体来说，每得到一个随机答案，当前温度都会乘 ，直到低于结束温度 在随机扰动时，会有 L : 马尔科夫链长度 在取答案(以越小越优为例)时，设第 个状态的答案 ，定义 如下： 在 之间随机取一个 ， 若 ，第 个状态将被接受 解决 背包问题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566% 模拟退火clear;clc;close all;N=input('有多少物品：');W=input('背包承重：');w=input('依次输入物品重量：');v=input('依次输入物品价值：');% initalpha=0.95;t_begin=200;t_end=0.1;t=t_begin;solution_new=ones(1,length(w));solution_current=zeros(1,length(w));value_current=0;value_best=0;solution_best=solution_current;counter=0;while(t&gt;t_end) counter=counter+1; for i = 1:100 index=randi([1,length(w)],1,1); solution_new(1,index)=~solution_new(1,index); solution_new.*w; % 每个位置相乘 while sum(solution_new.*w)&gt;W index=randi([1,length(w)],1,1); solution_new(1,index)=~solution_new(1,index); end value_new=sum(solution_new.*v); possibility=exp((value_new-value_current)/t); if possibility&gt;rand value_current=value_new; solution_current=solution_new; else solution_new=solution_current; end if value_current&gt;value_best value_best=value_current; solution_best=solution_current; end end value_list(counter,:)=value_best; solution_list(counter,:)=solution_best; t=t*alpha;endfigure(3);plot(value_list);xlabel('迭代次数');ylabel('目标函数值');title('适应度进化曲线');fprintf('最大价值：%f，货物重量%d\\n',value_best,sum(solution_best.*w));disp(['解：',num2str(solution_best)]); 遗传算法 神经网络","link":"/2023/10/30/three-algorithms-optimization/"},{"title":"康复训练","text":"写在前面：已经快一年没coding了，所以打算利用这一个月时间进行一个手感的找回，也好为 打下基础 2023.8.6 leetcode 6953 脑筋急转弯，正难则反 leetcode 2813 一开始没想到，看题解后知道是反悔贪心，然后就写了一个错误答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution {public: struct cmp2{ bool operator()(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b){ return a.first &gt; b.first; } }; pair&lt;int,int&gt; s[100010]; priority_queue&lt; pair&lt;int,int&gt; , vector&lt;pair&lt;int,int&gt; &gt;,cmp2 &gt; p; int n,tmp=0,lx=0,sum[100010]; static bool cmp1(pair&lt;int,int&gt; a,pair&lt;int,int&gt; b){ if(a.first==b.first) return a.second&lt;b.second; return a.first&gt;b.first; } long long findMaximumElegance(vector&lt;vector&lt;int&gt;&gt;&amp; items, int k) { n=items.size(); for(int i=1;i&lt;=n;i++){ s[i]=make_pair(items[i-1][0],items[i-1][1]); } sort(s+1,s+1+n,cmp1); for(int i=1;i&lt;=k;i++){ if(sum[s[i].second]==0){ lx++; sum[s[i].second]=1; tmp+=s[i].first; }else{ sum[s[i].second]++; tmp+=s[i].first; p.push(make_pair(s[i].first,s[i].second)); } } tmp+=lx*lx; if(p.empty()) return tmp; for(int i=k+1;i&lt;=n;i++){ if(sum[s[i].second]){continue;} int tmp1=tmp; while(!p.empty()&amp;&amp;sum[p.top().second]&lt;=1) p.pop(); if(p.empty()) return tmp; auto t=p.top(); tmp1-=t.first; tmp1+=s[i].first; tmp1-=lx*lx; tmp1+=(lx+1)*(lx+1); if(tmp1&gt;tmp){ lx++; tmp=tmp1; p.pop(); sum[t.second]--; sum[s[i].second]++; } } return tmp; }}; 原谅我的马蜂，意思就是先按利润排序，然后先取前 个，以取前 个这个状态为基准，判断加进来一个会否会使结果变大，如果会那就取，再以这个状态为基准判断下一个，如果不会那就不取，相当于舍弃掉这个东西了 ： 1items=[[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[3,2],[3,3],[3,4],[3,5],[3,6],[3,7],[3,8],[3,9],[3,10],[3,11]] k=10 1137 正解是以前 个这个状态为下界，然后尽可能往后取不同类别的东西，答案中类别数的平方使得线性的决策不一定正确，而贪心的思想告诉我们应该尽可能取不同类别的东西，严格来说正解才能称得上是贪心 AGC064A 有点意思的构造题 leetcode 1444 预处理+dp leetcode 1388 问题转化+环形dp的经典题型，取不相邻的最值，去头去尾分别dp取最值，不然就得存到状态里 ABC315E 建反图统计 的可达点，然后按拓扑序输出 ABC315D 快学英语吧，题都看错了…… ABC315F 向后传递 题，注意不需要跳过太多点，只需要讨论跳过 个以内的点的情况，于是可以把复杂度降到","link":"/2023/08/06/training-1/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","link":"/tags/Atcoder/"},{"name":"AppleScript","slug":"AppleScript","link":"/tags/AppleScript/"},{"name":"CodeForces","slug":"CodeForces","link":"/tags/CodeForces/"},{"name":"CMU","slug":"CMU","link":"/tags/CMU/"},{"name":"Databases","slug":"Databases","link":"/tags/Databases/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"MacOS","slug":"MacOS","link":"/tags/MacOS/"},{"name":"Terminal","slug":"Terminal","link":"/tags/Terminal/"},{"name":"思维题","slug":"思维题","link":"/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/"},{"name":"数学建模","slug":"数学建模","link":"/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"life","slug":"life","link":"/tags/life/"},{"name":"prufer序列","slug":"prufer序列","link":"/tags/prufer%E5%BA%8F%E5%88%97/"},{"name":"计数题","slug":"计数题","link":"/tags/%E8%AE%A1%E6%95%B0%E9%A2%98/"},{"name":"生成树","slug":"生成树","link":"/tags/%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Matlab","slug":"Matlab","link":"/tags/Matlab/"},{"name":"模拟退火","slug":"模拟退火","link":"/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"},{"name":"遗传算法","slug":"遗传算法","link":"/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"},{"name":"神经网络","slug":"神经网络","link":"/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}],"categories":[]}