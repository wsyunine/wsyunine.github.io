{"pages":[{"title":"关于我","text":"本人为华南理工大学 级软件工程专业在校生，此blog用来记录日常与学习心得 可以通过以下方式找到我： WeChat：wsy_jim QQ：3340307001 Github：wsyunine Snapchat：wsy_jim bilibili ：wsy_jim .a{ position: relative; top: 0px; width: 70vh; height: 50px; background-image: url(\"https://s1.ax1x.com/2023/09/05/pPrH9Et.jpg\"); background-size: cover; display: flex; justify-content: center; align-items: center; overflow: hidden; } WSY_JIM","link":"/about/index.html"},{"title":"友链","text":"Friends Interesting Things","link":"/links/index.html"}],"posts":[{"title":"ABC320","text":"写在前面： 菜菜 A 小小签到题，不能用 ，会爆 B 签到题， 判回文 C 老虎机 先枚举数码，再枚举顺序，然后模拟，考码力 D 双向建图跑 E 离散化后，排序模拟，要注意吃不到的情况，没有人退出或回来 F DP，不会做 三维DP 顺推，向外更新，比另一种方法好写多了 会点了，但不想写了 好像假了 正推比逆推少过了仨点 难受 回头再说 G 加强版老虎机 二分+二分图 暂时咕","link":"/2023/09/19/ABC320/"},{"title":"AppleScript学习笔记","text":"写在前面：在搭建班级代码仓库时遇到了需要编写脚本的问题，所以来学习一下怎么编写 ，感觉用好了这门脚本语言 将会很强大 我不用学了，因为 帮我学了 脚本1： 用来分类文件 在文件夹1下有一些文件，文件名前两个数码为序号，在文件夹2下有一些文件夹，文件夹名为序号，现在要求运行脚本后，存在文件夹1下的所有文件按照序号复制一份到文件夹2下对应名字的文件夹下 12345678910111213141516171819202122232425262728-- 设置文件夹路径set folder1Path to \"路径1\"set folder2Path to \"路径2\"-- 获取文件夹1中的所有文件tell application \"System Events\" set folder1Files to every file of folder folder1Pathend tell-- 遍历文件并复制到相应的文件夹中repeat with aFile in folder1Files set filePath to POSIX path of (aFile as alias) set fileName to name of aFile -- 提取文件名前两个数码作为序号 set serialNumber to text 1 thru 2 of fileName -- 确定目标文件夹的路径 set targetFolder to folder2Path &amp; \"/\" &amp; serialNumber -- 如果目标文件夹不存在，则创建它 do shell script \"mkdir -p \" &amp; quoted form of POSIX path of targetFolder -- 使用 shell 命令复制文件 do shell script \"cp \" &amp; quoted form of filePath &amp; \" \" &amp; quoted form of POSIX path of targetFolderend repeatdisplay dialog \"复制完成！\" 脚本2： 用来创建文件夹 在文件夹中创建名为 01、02、……、62 的总共62个文件夹。 1234567891011-- 设置文件夹1路径set folder1Path to \"路径\" -- 请将路径替换为实际路径-- 创建文件夹repeat with i from 1 to 62 set folderNumber to text -2 thru -1 of (\"0\" &amp; i) -- 将数字转为两位数格式，如1变为01 set newFolderPath to folder1Path &amp; \"/\" &amp; folderNumber do shell script \"mkdir -p \" &amp; quoted form of newFolderPathend repeatdisplay dialog \"创建完成！\"","link":"/2023/09/16/AppleScript/"},{"title":"CF1872","text":"写在前面： 到学校第一次打 还算可以 A 签到题，基本运算，读懂题即可 ceil(x) 是对 向上取整，floor(x) 是对 向下取整 B 签到题，读懂题即可，线性扫陷阱 C 小构造题，如果范围里有大于 的偶数，那就输出 和 ，如果只有一个奇数，那就分解因数，如果有除 和它本身的因数，就输出此因数和 与此因数的差，找不到就输出 ，注意 都不符合题意需特判 D 小数学题，发现 的倍数数量相对于整体是少数，所以只需要考虑倍数， 的公倍数被加一次减一次相当于没用，于是我们求出来是 的倍数但不是 的倍数的个数以及是 的倍数但不是 的倍数的个数，依次把最大的若干数和最小的若干数填进去即可 E 看到几种做法 1. 线段树（我的做法） 2. 异或前缀和 3. 分块 感觉线段树还是比较好想的，维护区间内属于 的异或和属于 的异或和，修改就是 并打 ，我做的时候出现了一些问题，导致样例能过，但是第二个点就过不去了，最后几分钟调出来了，发现是打 的方式不对，有的 不能及时下放，在 本来就为 的节点再进行修改， 应该变为 ，我忽略了这个问题，最后切了 F 基环树森林的基本做法，先处理环下树一定最优，然后找环，环中舍掉贡献最少的边，定出一个起点按顺序输出，最劣复杂度 在一个有向图中,每一个点都有唯一的一个出边,那么这个图就是一棵基环树。 G 奇技淫巧题 发现操作肯定是选非 的数做两端更优，所以只需要枚举非 的数，处理出前缀积和前缀和，然后 枚举，有人担心 过不了，其实确实过不了，考虑一些可以直接得出答案的情况，当一段数的积够大，大到一定程度，就一定取整段 数据范围告诉我们如果什么操作都不做，所有数的和最大应该是 ，当积大于这个数时，就可以省去枚举的步骤，以 为底其的对数不超过 ，枚举飞快 第一次手撕 题纪念一下","link":"/2023/09/08/CF1872/"},{"title":"CF1879","text":"写在前面： 的 A 签到题，注意读题，特判后直接输出答案 B 符合条件的摆法，一定满足每行都有或者每列都有 所以按行取一次最小值再按列取一次最小值，输出两次的最小值 C 小小计数题 预处理出 以及 如果有连续的一串 或 ，在 个里面取 个，最后再乘上操作数的阶乘 D 求全部区间的区间长度 元素异或和 先考虑 时的做法 求出来异或前缀和，对于一个选定的区间右端点，如果该点异或前缀和为 ，那么左端点的异或前缀和只能是 ，该区间才对答案有贡献，另外一种情况也一样，于是我们扫一遍序列，分别记录 和 的个数以及到右端点的距离之和，有点小技巧，每次扫到 时就加上 对应的距离和，每次扫到 时就加上 对应的距离和，细节处理一下就好 然后 就按位拆开分别处理即可 E 交互题，想假了 一开始的做法： 对于一个点，其连儿子的边都是一种颜色，连父亲的边是另一种颜色，当一个点有大于 个儿子时，可以通过数量判断父亲，一棵树都是这样的节点的话，就只需要两种颜色，当一个点只有一个儿子时，就是需要引入另一种颜色，所以我们只需要统计儿子个数之为 的点形成的链的最大长度即可，最小颜色就是 实际上，想复杂了 颜色最多 种 对于多个儿子的节点直接找 ，对于一个儿子的点，相邻边存在的颜色也最多只有 种，颜色对 取模后就完全可以确定边的优先级 还有一个点就是 连儿子的边的颜色可以不相同 贴个代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;climits&gt;#include&lt;iomanip&gt;using namespace std;#define N 100010template&lt;typename T&gt;inline void read(T &amp;x){ x=0;bool flg=0;char c=getchar(); for(;!isdigit(c);c=getchar()) if(c=='-') flg=1; for(;isdigit(c);c=getchar()) x=x*10+(c^48); if(flg) x=-x;}int n,p[N];vector&lt;int&gt; e[110];int cl[N],mx[110],dmx=0;void dfs1(int x,int c){ cl[x]=c;dmx=max(dmx,c); for(auto i:e[x]){ if(e[x].size()==1) dfs1(i,c%3+1); else{ if(c!=1) dfs1(i,1); else dfs1(i,2); } }}int main(){ read(n); for(int i=2;i&lt;=n;i++) read(p[i]),e[p[i]].push_back(i); for(int i=0;i&lt;e[1].size();i++){ dmx=1; dfs1(e[1][i],1); if(dmx==1){mx[i]=1;continue;} else if(dmx==2){mx[i]=2;continue;} else{ dmx=2; dfs1(e[1][i],2); if(dmx==2) mx[i]=2; else mx[i]=3; } } for(int i=0;i&lt;e[1].size();i++) dmx=max(dmx,mx[i]); cout&lt;&lt;dmx&lt;&lt;endl; for(int i=2;i&lt;=n;i++) cout&lt;&lt;cl[i]&lt;&lt;\" \"; cout&lt;&lt;endl; int op; read(op); while(op==0){ int tmp=0; for(int i=1,o=1;i&lt;=dmx;i++,o*=2){ int a; read(a); if(a==1) tmp+=o; } if(tmp==1||tmp==3) cout&lt;&lt;1&lt;&lt;endl; else if(tmp==2||tmp==6) cout&lt;&lt;2&lt;&lt;endl; else cout&lt;&lt;3&lt;&lt;endl; read(op); } return 0;} F 问题转换：对于 从 枚举到 ，求出 第一大的下标和值以及第二大的值 数论分块+ST表 调死我了 对于每个 ，按 分块，由调和级数，遍历的复杂度也不会超过 ，于是只需对 处理 查询第一大的下标和值以及第二大的值， 表改改就行了，但是💩山代码 贴个代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;climits&gt;#include&lt;iomanip&gt;using namespace std;#define N 400010#define ll long longtemplate&lt;typename T&gt;inline void read(T &amp;x){ x=0;bool flg=0;char c=getchar(); for(;!isdigit(c);c=getchar()) if(c=='-') flg=1; for(;isdigit(c);c=getchar()) x=x*10+(c^48); if(flg) x=-x;}int t;int mx=0;ll ans[N];int n,f1[30][N],f2[30][N],g[30][N],lg[N]={-1};int a[N];struct inp{ int h,a; int num;}p[N];struct node{ ll idx,k1,k2;};bool cmp(inp a,inp b){ return a.a&lt;b.a;}void init(){ for(int i=1;i&lt;=n;i++) f1[0][i]=p[i].h,f2[0][i]=0,lg[i]=lg[i/2]+1,g[0][i]=p[i].num; for(int i=1;i&lt;=lg[n];i++){ for(int j=1;j+(1&lt;&lt;i)-1&lt;=n;j++){ if(f1[i-1][j]&lt;f1[i-1][j+(1&lt;&lt;(i-1))]){ f1[i][j]=f1[i-1][j+(1&lt;&lt;(i-1))]; g[i][j]=g[i-1][j+(1&lt;&lt;(i-1))]; f2[i][j]=max(f1[i-1][j],f2[i-1][j+(1&lt;&lt;(i-1))]); }else if(f1[i-1][j]&gt;f1[i-1][j+(1&lt;&lt;(i-1))]){ f1[i][j]=f1[i-1][j]; g[i][j]=g[i-1][j]; f2[i][j]=max(f2[i-1][j],f1[i-1][j+(1&lt;&lt;(i-1))]); }else{ f1[i][j]=f1[i-1][j]; g[i][j]=-1; f2[i][j]=max(f2[i-1][j],f2[i-1][j+(1&lt;&lt;(i-1))]); } } }}node query(int l,int r){ node ans; int len=lg[r-l+1]; if(f1[len][l]&gt;f1[len][r-(1&lt;&lt;len)+1]){ ans.k1=f1[len][l]; ans.idx=g[len][l]; ans.k2=max(f1[len][r-(1&lt;&lt;len)+1],f2[len][l]); }else if(f1[len][l]&lt;f1[len][r-(1&lt;&lt;len)+1]){ ans.k1=f1[len][r-(1&lt;&lt;len)+1]; ans.idx=g[len][r-(1&lt;&lt;len)+1]; ans.k2=max(f2[len][r-(1&lt;&lt;len)+1],f1[len][l]); }else{ ans.k1=f1[len][l]; ans.k2=max(f2[len][l],f2[len][r-(1&lt;&lt;len)+1]); if(g[len][l]==g[len][r-(1&lt;&lt;len)+1]) ans.idx=g[len][l]; else ans.idx=-1; } return ans;}int main(){ read(t); while(t--){ read(n);mx=0; for(int i=1;i&lt;=n;i++) read(p[i].h),p[i].num=i,ans[i]=0; for(int i=1;i&lt;=n;i++) read(p[i].a),mx=max(mx,p[i].a); sort(p+1,p+1+n,cmp); for(int i=1;i&lt;=n;i++) a[i]=p[i].a; init(); for(int i=1;i&lt;=mx;i++){ node tmp,ad; ad.idx=0,ad.k1=0,ad.k2=0; // cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;ceil((1.0*mx)/(1.0*i))&lt;&lt;endl; for(int c=1;c&lt;=ceil((1.0*mx)/(1.0*i));c++){ int l=lower_bound(a+1,a+n+1,i*(c-1)+1)-a; int r=upper_bound(a+1,a+n+1,i*c)-a-1; // cout&lt;&lt;i*(c-1)+1&lt;&lt;\" \"&lt;&lt;i*c&lt;&lt;\" \"&lt;&lt;l&lt;&lt;\" \"&lt;&lt;r&lt;&lt;endl; if(l&gt;r) continue; tmp=query(l,r); // cout&lt;&lt;l&lt;&lt;\" \"&lt;&lt;r&lt;&lt;\" \"&lt;&lt;tmp.k1&lt;&lt;\" \"&lt;&lt;tmp.idx&lt;&lt;\" \"&lt;&lt;tmp.k2&lt;&lt;endl; if(tmp.k1*c&gt;ad.k1){ ad.k2=max(ad.k1,tmp.k2*c); ad.k1=tmp.k1*c; ad.idx=tmp.idx; }else if(tmp.k1*c&lt;ad.k1){ ad.k2=max(ad.k2,tmp.k1*c); }else{ ad.idx=-1; ad.k2=max(ad.k2,tmp.k2*c); } } // cout&lt;&lt;ad.k1&lt;&lt;\" \"&lt;&lt;ad.idx&lt;&lt;\" \"&lt;&lt;ad.k2&lt;&lt;endl; if(ad.idx==-1) continue; ans[ad.idx]=max(ans[ad.idx],ad.k1-ad.k2); } for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;\" \"; cout&lt;&lt;endl; } return 0;}","link":"/2023/09/26/CF1879/"},{"title":"瞎做到的好题","text":"写在前面：随便刷到的好题 ABC288D 有差分和剩余系的思想，但是不用真的差分，把整个序列按 分类，会发现，每次只改变每一类数中的一个，所以要想把所有数消成 ，只需要区间内每类数之和相等即可，挨个消，消到最后，一定可以整成 这种形式 P9753 跟括号匹配一点都不一样 首先要找两个相邻且相同的字符，然后才能往外消，不妨设 为第 个字符往后最小的 ，使 可被消除，然后 表示从第 个字符跳多少段最小可消除段才能到不能跳为止，答案就是 至于 转移，需要只需要再记录一个 表示从 开始跳可消除段，跳到 这个字符的所在下标，倒序遍历就行了 P5369 数据范围可以看出来是状压 考虑最大前缀和有什么性质，假设从 加到 为最大前缀和（ 为满足条件的最大 ） ： 在 区间内，所有的后缀和都 ，除了整体，整体可以 ，因为必须要算上一个数 在 区间内 ，所有的前缀和都 所以对于每个状态 ，我们记录用全集合内的元素可以满足 1. 的方案数 以及可以满足 2. 的方案数 对于 的特殊情况，我们可以多开一维 ，记录是否整体 关于转移，用向外转移，即 就不会漏辣 2022ICPC_Nanjing_D 乐子题，打表看出来最后一定会成为一个不变的序列，只有第一个数与别的数不同，是其他数的两倍，那个 可以看成无限次 2022CCPC_Guangzhou_H 直接想嘛，记录每个序列里没有的数的奇偶性，A一定填奇数更优，B一定填偶数更优，直接模拟 2022ICPC_Jinan_E 每次滑动进出的元素奇偶性相同，考虑根据奇偶性一定相同的元素分块，有 个大小为 的块，有 个大小为 的块，解 这个方程，用exgcd求出一个特殊解 好了，然后通解就是 ，根据限制分别求出来 的取值范围，看看有无交集 是个小nb题 代码放这了 1234567891011121314151617181920212223242526272829303132333435363738//头文件int t;int n,k,p,q;int exgcd(int &amp;x,int &amp;y,int a,int b){ if(b==0){x=1,y=0;return a;} int g=exgcd(y,x,b,a%b); y-=(a/b)*x; return g;}int main(){ read(t); while(t--){ read(n),read(k); int a,b,x,y; a=n/k+1,b=n/k; p=n%k,q=k-p; int g=exgcd(x,y,a,b); if((n/2)%g!=0){cout&lt;&lt;\"No\"&lt;&lt;endl;continue;} x*=(n/2)/g; y*=(n/2)/g; int l1=-x/b,l2=(y-q)/a; if(l1*b+x&lt;0) l1++; if(y-l2*a&gt;q) l2++; int r1=(p-x)/b,r2=y/a; if(r1*b+x&gt;p) r1--; if(y-r2*a&lt;0) r2--; if(max(l1,l2)&lt;=min(r1,r2)) cout&lt;&lt;\"Yes\"&lt;&lt;endl; else cout&lt;&lt;\"No\"&lt;&lt;endl; } return 0;} 2022CCPC_Mianyang_G 纯模拟，但是有意思的地方在于对时间复杂度的预测，为什么暴力能过，因为在一个 的排列里面，极值最多只可能有 个，所以模拟最劣复杂度为","link":"/2023/10/13/good-problem/"},{"title":"Graph Theory学习笔记","text":"写在前面：开始学习图论 1 Graph 1.1 Graphs and Their Representation 图的三要素： order : 点的总数 size : 边的总数 loop : 自环 parallel edge : 重边 表示与点 相连的点集，不包括 finite graph : 有限图（order 和 size 都有限） null graph : 空图（order 为 ） A graph is simple if it has no loops or parallel edges. complete graph empty graph bipartite graph complete bipartite graph star path cycle connected : 通过分割定义 planar graph : 可以画到平面上&amp;边与边不相交 planar embedding : 平面图在平面上让边与边不相交的一种画法 embedding : 图的让边与边不相交的一种画法 incidence matrix : 关联矩阵 adjacency matrix : 邻接矩阵 adjacency list : 邻接表 bipartite adjacency matrix vertex degree | : 和点相连的边数（自环算两条边） : the minimum degree of the vertices of : the maximum degree of the vertices of : Theorem 1.1 For any graph , Corollary 1.2 In any graph, the number of vertices of odd degree is even. 证明考虑模 剩余系下每个点的度 k-regular : for all regular graph : -regular for some cubic graph : -regular praphs isolated vertex","link":"/2023/10/24/Graph-Theory/"},{"title":"CF1882","text":"写在前面： 睡觉场 A 签到，以 或 开头，扫过去 B 不太友好的 重构了一遍 思想就是试着每次去除集合里的一个元素，并且模拟一下看看连带着会去除多少别的元素，肯定是去除的越少越好，考验码力 C 写完 看完 就睡了","link":"/2023/09/30/CF1882/"},{"title":"队内国庆欢乐场4","text":"写在前面：刚进队就看见这个，吓一跳 A B C D 看懂题就是个小水题啦，只能三个三个换，所以位置的奇偶性是不变的，所以直接数量判存在，模拟搞次数，还有，写简单点，没必要大长屎山代码 E F G 坑及其多，基本做法就是差值始终不变，所以排序后找差值的 ，如果为 则不存在，别的情况都存在，特判极多 全是 需要特判， 需要严格大于 一开始就不需要改动的需要特判 最后差值的 需要找 H 简 单 且 恶 心 注意几个地方： 字符相同可以单拎出来全改成 无论如何保证前面的全是 ，到最后再考虑剩下的选择 在前面一个字符串中选了一个 ，后面就必须在另一个字符串中选一个字符 （去重后）一要考虑两个字符全不为 ，二要考虑两个字符有一个是 的情况 前面自由选择时要为后面留出空间，前一对后一 后面有可能会有一个位置是空出来的（奇数情况），尽量让这个空出来的位置靠前，改为尽可能靠 的字符 选字符串 再选字符串 可以抵消 I J 发现取石子后，数值的单调性是不变的，于是找极大值和极小值，极小值一定可以取到 ，极大值的取值跟与极小值之间距离有关，由此算出能移动的最大步数，判断输赢 K L","link":"/2023/10/07/group-001/"},{"title":"数学建模——数据预处理","text":"写在前面：好久没更新博客了，不知道因为什么原因，考试周快过去了，插空更一个队长分享的一个课程的总结。 边听课边写线代卷子，听了个大概，主要讲的是针对大数据题做的数据预处理专题，深有体会，经过数理大赛和亚太杯的胡乱搞，感觉前期的数据预处理过程和结果对后期的建模确实有比较重要的影响，故想写一些东西加深印象。 数据预处理一般包括：数据集成、数据规约、数据清洗、数据变换，下面挨个来说 数据集成 数据集成一般指把来自不同数据源、用不同表示规则表示的数据整合为同一类型、统一表示规则的数据方便处理。 实体识别问题 就比如说最近一次的亚太赛的 题，要求对图片中苹果的个数、位置、重量、成熟程度进行识别，当时我们使用的方法是基于数连通块个数的方法再进行优化，采用的数据集成方法就是分别读取图片中每个像素点的 值，然后整合到一个表格中，再进行下一步。 实体识别问题再提一嘴，可以使用 labelimg 来对图片进行标注框画，建模一般使用深度学习模型 数据字段问题 刚好对应数理大赛的赛题，房价预测模型，房子的属性参数不止有数值型数据，还有非数值型数据比如字符串数据，如果该标签为分类变量，我们当时处理成了 变量数据，大大增加了标签数量，非分类变量一般与房价关联程度不高，直接删去该标签 冗余和相关性分析 如果一个标签能够通过其他标签推出或表示，即相关程度大，那么这个标签就是冗余数据。判断冗余数据可以使用相关性分析。 元组重复","link":"/2023/12/24/modeling-prework/"},{"title":"你不是第一次当新生了，应该知道怎么做了吧","text":"开学了，写点东西 day -2 大姨带着元宝来送我上火车，元宝一见到我就抱住我说：“哥哥你什么时候才回来看我啊”，真的佩服小孩子的记性，明明上了高中以后就没再见过一面了，却还是和我亲的不行 在火车站坐着，大姨让我看着元宝，却带回来一袋子麦当劳，让我上车吃，姥姥的饺子还在保温杯里，大姨说容易坏，上车先把麦当劳吃了吧，然后我就在车上吧饺子和汉堡全吃了，撑得睡不着觉 btw 退役军人证是真的爽，人们排了好长的队，但是直接从队首进到站台了 上车以后看了两集生活大爆炸就睡了，防止手机没电一直开着超级省电 day -1 早晨七点起的，好像到湖南了，早饭吃了碗泡面就回卧铺上躺着了，还做成了一项伟业：把五个箱子袋子缩减到了四个 南方的山和水比北方多多了，一会儿进一个隧道，一会儿跨一条湖，我坐在窗户前面看了一个多小时，好像被吸引住了，可能也是无聊 中午12点到广州了，和我爸我妈会和，也是这个时候知道会有台风，辅导员说可以提前入住，然后我们就直接去华工了，先坐的 号线，从广州北站到高增，再倒 号线，从高增坐到汉溪长隆，最后倒 号线，到终点站大学城南，不知道为什么，去一座城市，我就特别想坐一下，这个城市的地铁，就就就特别喜欢underground（北京地铁 号线四惠前面的那段 在志愿者的指引和导航的支持下找到了 ，打开宿舍门发现 已经到了，我才想起来 是临干，简单认识了一下就开始收拾东西了，收拾了一下午，把蚊帐弄好了就溜了，晚上住的酒店还不错 但是，酒店没有热水，我斗胆洗了发凉水澡，成功把自己弄感冒了，鼻子堵了，打喷嚏打个不停，没办法，还是睡了，睡前看到明天下午 点以后让准备好吃的和用的，要停工停业，给我吓一哆嗦，但鼻子还是堵的，难受 day 0 早晨六点，被一口气憋醒，然后就睡不着了，于是起来吃早饭，发现这里的店真的是开门好晚，七点都没几家点开门，吃了口上海小笼包就赶到学校了，继续收拾东西 收拾了一上午以后看看还缺垃圾桶、盆等大件的生活用品，看到这里便利店真的卖的有点点小贵，在学校食堂吃了第一顿饭后，我们就打车到了最近的沃尔玛，说最近也不近，打车都花了四十多，后来一想，感觉还不如在学校买呢，打车都贵的要死 下了车，不知道为啥感觉走不动道，累的不行，头也晕，有点烧，我妈觉得我又阳了，我也觉得，硬撑着买完了一些东西，打车回酒店睡了一下午，路上买了些药，吃了，好点，但不多 晚上开始下雨了，是台风吗，可能是吧，说是 号凌晨离我所在地最近，也不管啦，反正也病着，出不去 家长回去的火车停运了，找了半天候补票，最后还是没订上 day 1 今天报道，下着雨，吃了顿广东早茶就打车去华工了，收拾东西，线上报个到，去交个户口迁移证，该弄的都弄了 发现病情有点改善 我说，就在宿舍待着吧，他们说，订上票了 看到 在看闫总的课，突然想起来高一的时候自己听闫总的课，觉得这怎么可能是从我们学校出来的，我怎么没学成这样， 就退役的小 b 崽汁斗胆挑战 ，看后续吧 跟 聊了会儿天，感觉是个大佬，作息规律，还学的多，感觉卷不过的样子 /qq 跟 渗透了一下想当学习委员的意愿 晚上 买的洗衣机到了，只有我和 在宿舍，我们没管快递师傅带个推车的建议，空着手去了，然后抬着大洗衣机，从天桥底下走到宿舍底下，然后又搬上四楼，搬的满头大汗，得，病是完全好了 在宿舍待的第一个晚上，我就知道了山东有多卷，反正比河北卷 day 2 快七点起的，洗漱完， 带我去见另外几个临干和他们的室友，先见到 和 ，然后在食堂见到了 和 ，和他们一块吃早饭，我要的煎饼，感觉和北方的做法不太一样，吃起来也还行，我们因为拿体检表晚来了点所以只是安静的吃（社恐 估计是他们都提前见过了，对我还比较陌生，被 问叫什么，好像又被认错名字里的字了，果然是个易错字，高中老师每人念错一遍的威力 然后在黄老师的带领下逛了一圈校园，知道路怎么走啦，学校还是蛮大的嘛（赞赏 然后去体育馆体检了，体育馆的屋顶好像某处遗址的材质，不是很懂 去和家长告别，在正门拍了几张照片，在 ❤️ 那里拍了几张，最后吃一顿饭就回浙江了，我也带着点东西回宿舍了 回到宿舍， 又要去当志愿者，于是就我一个人了，和 视频了会，聊挺开心，回来 就告诉我他也想当学习委员，好像有点棘手，我确实胜算不太大，戴耳机，听歌，洗衣服，晾上， 来啦，帮他搬东西去，然后吃晚饭 晚上自己骑着小蓝去 新天地了，人蛮多，蛮繁华，戴着耳机，人声听不到了，只有音乐声，找点好位置拍点照，看着，走着，突然发现自己是只有自己在这座城市上了，还好吧，有点说不出的感觉 骑着车子姥姥给我打电话，第一个没接到，我说自己在洗衣服，我要是说我自己在外面逛，肯定又要被担心被拐走了 感觉黄老师确实蟀 day 3 报道第三天，早晨吃饭带上 了， 又认了一下，吃完去拿快递回宿舍了 我跟 说我改成科创委员吧，我还是蛮好说话的（自豪 下午我想出去玩，问他们去不去，然后就都去了，去的北京路，坐了一个小时地铁，到了一个比较古老又繁华的道路上，左边是古老的破旧不堪的建筑，残留着上个世纪的遗韵，右边是大商场，展示着繁华大都市的脸面，稍微转了转，在这里可以看到无轨电车，相当于公交，但是上面连着线，第一次见，新鲜事物 去吃冰，点了个里面有芒果和奶皮的甜品还有抹茶味的（应该是）冰沙，做的好高，分量挺足，就是吃完容易窜，就像 一样 然后我们去大沙头游船码头坐船去啦，一个人 块钱，还可以，主要是江风太好吹了，感觉一切不好的事都能被它吹走，然后只留下享受，大桥从头顶上略过，广州塔从身旁游过，想用无人机拍下来这样的景象 船上有专门的摄影师，先给你拍照，然后给你洗出来装上纸质相框，问你要三十块拿走，最后我们自己在船上拍了一张，能体会一次就不错 今天最后一位同仁 来了， 宿舍齐活，直接启动！ day 4 因为明天要考试了，所以打算复习复习，上午听了个四级听力，错了 个，再听一个，听不下去了，听不懂，然后开始写阅读，错了 个，不写了 拿快递，然后拿快递，然后更新桌面，二阶段宿舍改造计划启动 晚上有学生会招新，去听了听，看中了三个：外联部、宣传部、学术科技部，最后报了外联和宣传 试了下收音机，金属味有点重 day 5 早晨吃完饭去照片采集，碰到 ， 看了看考场，回宿舍歇着了 看了看单词，还是有点不放心收音效果，就没带收音机（惊（不是故意的（带了个空盒子（以为带上了，慌得我直接找旁边刚考完的人借了个，最后还没用到 在 门口看到了 力（喜 中午吃的意面，不好吃，差评 取快递，三阶段宿舍改造计划启动 晚上开学典礼，去食堂感觉不想吃，就买了瓶可乐去音乐厅后面的座位上歇着了，看 说编程领域 的使用率还是比较高的，瞬间舒心 听课听的很认真，有被教育到了，要好好学习咯，睡觉啦 /dy day 6 下了一天雨，在宿舍待了一整天，中午饭晚上饭都在宿舍吃零食，根本不想出宿舍 上午敲了一上午代码，打了会音游，下午睡到 点半，起来梦了会游，去面试外联部了，口才不太好，想到的都没说出来，感觉不是太妙 晚上说是有集会但是大雨倾盆，逃了 到床上打 找手感，切了 道，感觉良好 day 7 依然在下雨，上午是班级破冰活动，早上准备去，拿上新买的雨伞，但是发现坏了，我才用了一次啊 /dk，结果在楼下买了个高达 元的雨伞，早饭都没吃就去了 时间好像只有一个半小时，比较紧，让所有人简单介绍了下自己，然后又让班委竞选了一下（然而每个班委只有一个人竞选）没尬住，大胜利 搞完去拿快递，发现都不知道自己取了哪个没取哪个，取了个寂寞，回来就在遇见小面找了个座位吃了 块钱的软骨丸子汤面、羊肉串还有冰粉，还不错，就是有点贵 回到宿舍发现自己耳机进水了一样，一直有电流声，md我快两百块钱买的啊，怎么这么不经用 下午干正事 晚上听詹书记教育我们，感觉讲课跟 一样抽象，喜欢举例子，喜欢说看似废话的话，意识流式讲话，原来有学识的人都是这么讲话，爱了爱了 day 8 今天上午是全校的开学典礼，下午是全校的新生安全教育，一散会就被叫去搬书了，分完书回宿舍写作业，写到半夜才写完 day 9 今天早晨起晚了，赶忙去七楼面试宣传部，平稳地完成了，晚上告诉我通过了 yeah 打算出去玩，简单找了找资料，首先先去坐了有轨电车，从万胜围到广州塔，发现那里有步行桥可以跨珠江，觉得傍晚来风景最好，就预约了六点到七点的时间，然后坐 线去广州图书馆和广州博物馆，座位和大厅是没有隔离连着的，感觉人多的话工作看书会有点吵，逛了一圈出来想去博物馆，发现需要预约并且当天已经预约满了，就只能换个地方去了，去了旁边的 艺术购物中心，上流人士的游览场所，有钢琴表演，金碧辉煌，我这种土狗逛了逛就溜了，溜去彩虹桥旁边的西华路吃小吃，彩虹桥确实是个很魔幻的地铁站，非常大，天花板上装饰着彩虹，西华路上人一般多，只有那么几家网红店门口排着长队，剩下的店里都看不到顾客，我点了一份煎饺还有一杯杨枝甘露，还是蛮好吃的，回图书馆看了会书，就去广州塔的步行桥上欣赏日落了，但是太阳看不见一点，扫兴地去五山校区听华南虎宣讲会了，看到好多名人，抽奖还中奖了（喜，想加入，但是再看看吧 明天就开课了，新生记录就先这样完结吧，先让我学学怎么学习大学的知识……","link":"/2023/09/06/new-student/"},{"title":"练一些分治题","text":"写在前面：分治这个东西好像容易被大家忘记，专门找一些题练练 Luogu P1429 分治基本思想，确定一个分割点，各自处理左右两部分答案，最后合并答案 先考虑一维，确定一个中间点，假设左右分别都求出来了最近点对，然后需要求整个部分的答案，需要考虑跨分界点的点对，设 为左右两边答案中小的那个，只需要考虑分界点左右距离为 内的点，至多有两个点，复杂度降到 二维一样，按其中一维像上面做之后，把另一维排序，取靠近分界点的点进行枚举，枚举也无须做到平方级别，每个点只需要尽可能枚举相近的点即可，可以证明点数不超过 个，复杂度降到 LOJ #6490 也是区间分成两半去考虑，当两边的答案处理好之后，需要考虑跨过 的区间 以左边为例，依次枚举左端点 ，求出跨 的长度在 的区间中最大的区间，具体用前缀和 + 表实现 查找，记录下来 再往后扫， 的答案就是 ， 一定是在 记录的最大区间里面的 右边同样，注意开要","link":"/2023/09/07/%E5%88%86%E6%B2%BB/"},{"title":"tarjan","text":"写在前面：图论中一个非常重要的算法—— 算法 tarjan 总述 有向图中的tarjan 强连通分量 点双连通分量 边双连通分量 无向图中的tarjan 割边 模板题：1192. 查找集群内的关键连接 - 力扣（LeetCode） 割点 模板题：P3388 【模板】割点（割顶） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)","link":"/2023/08/12/tarjan/"},{"title":"有关完全图中生成树数量问题的思考","text":"写在前面：在复健矩阵的时候发现了 [NOI2007]生成树计数 这个题，遂起兴研究生成树计数 个结点的环的生成树个数为 个结点的完全图的生成树个数为 第一句话很好理解，只要去除环中的任意一条边，就是一棵生成树 第二句话也叫 公式，证明需要用到 序列的东西，顺便提一嘴， 序列就是为证明 公式而诞生的 犹记两年前 讲题时给我们讲到过这个东西，但是已经忘掉了 Prufer Code 以下提到的树都是有标号无根树 每棵结点数大于 的树都对应唯一一个 序列，每个 序列也唯一对应一棵结点数大于 的树，两者为双射关系 由树构造 序列步骤如下： 找到叶子结点中编号最小的，记作 ，将 的父结点 加入序列 删去 结点 重复步骤 1. 和 2. ，直到整棵树只剩下两个结点，结束 显然，若整棵树有 个结点，那么该树对应的 序列长度应该为 由构造过程，可以得出两个结论： 结点 最后一定没有被删除 每个结点的度是序列中该结点出现次数 根据构造过程，相似地，可以得出由 序列构造树的方法： 根据度数为 确定当前的叶子结点，找出叶子结点中编号最小的结点，记作 ，将 的父结点设为序列中第一个没有遍历过的结点 删去 ， 度数 ，如果 度数为 ，那么把其加入叶子节点集合中 重复 1. 和 2. ，最后会剩下两个叶子结点，将其连接，结束 由每一步构造的唯一性以及每一步反构造的唯一性，由反证法可以得出 不存在两个 序列对应同一棵树 不存在两棵树对应同一个 序列 设 为所有树构成的集合， 为所有 序列构成的集合，由 1. 得 ，由 2. 得 ，即 ，得证 若要钦定根，最后可以添加一个根节点，序列长度变为 ，相似地，可以唯一确定一棵有标号有根树 更好的构造与反构造方法 模板 用代码模拟构造和反构造当然可以用小根堆，时间复杂度 还有一种更为快速的方法 构造： 找到编号最小的叶子结点 ，父结点 加入序列 若删去 后， 变为叶子结点，且编号比 小，则 为当前编号最小的叶子结点，直接令 为 ，重复操作 1. 和 2. 若不满足 2. ，将 自增，直到找到下一个未删除的叶子结点 最多自增 次，时间复杂度 12345678910111213141516int p;for(int i=1;i&lt;=n;i++) if(d[i]==1){p=i;break;}vector&lt;int&gt; prufer;int l=p;while(prufer.size()&lt;n-2){ int f=fa[l]; prufer.push_back(f); d[f]--; if(d[f]==1&amp;&amp;f&lt;p) l=f; else{ p++; while(d[p]!=1) p++; l=p; }} 反构造：同上 看代码 12345678910111213141516int p;for(int i=1;i&lt;=n;i++) if(d[i]==1){p=i;break;}int l=p;for(int i=1;i&lt;=n-2;i++){ int f; f=fa[l]=prufer[i]; d[f]--; if(d[f]==1&amp;&amp;f&lt;p) l=f; else{ p++; while(d[p]!=1) p++; l=p; }}fa[l]=n;//最后剩下的两个点 OK 学完 序列后就能证明 公式了，由于每个序列唯一对应一棵树，那么长度为 的序列的总个数就是 个点的完全图的生成树个数，也就是 个 有根树对应 序列长度为 ，数量为 个 来点数学 如果给定 并固定每个点的度数，那么能形成的有标号无根树有多少？ 考虑 序列，先阶乘再去重就好啦，设第 个点度数为 ，答案是 板子 完全二分图生成树个数？ 左部点 个，右部点 个 构造 序列最后剩下的两个点一定是左部点一个右部点一个，考虑删去的点，删去一个左部点一定会往序列填一个右部点，删去一个右部点一定会往序列填一个左部点，最后的序列中左部点的数量为 个，右部点数量为 个， 序列共有 个，答案也是这个 以上 都需要特判o 当时找了几道题，我去做做 CF917D（这道题也是曾经 佬课件上的一道题）但是我不会二项式反演 ARC106F（需要生成函数，不会捏） 牛客挑战赛48C（这个可以写） TopCoder SRM697 div1 hard 是这道 （看不懂所以不写） 把一些参考放在这里 《Tree-structured Data Regeneration with Network Coding in Distributed Storage Systems》 【朝夕的ACM笔记】图论-Prufer序列 - 知乎 (zhihu.com) Prufer 序列 - Achtoria - 博客园 (cnblogs.com)","link":"/2023/10/17/%E5%AE%8C%E5%85%A8%E5%9B%BE%E4%B8%AD%E7%94%9F%E6%88%90%E6%A0%91%E6%95%B0%E9%87%8F/"},{"title":"康复训练","text":"写在前面：已经快一年没coding了，所以打算利用这一个月时间进行一个手感的找回，也好为 打下基础 2023.8.6 leetcode 6953 脑筋急转弯，正难则反 leetcode 2813 一开始没想到，看题解后知道是反悔贪心，然后就写了一个错误答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution {public: struct cmp2{ bool operator()(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b){ return a.first &gt; b.first; } }; pair&lt;int,int&gt; s[100010]; priority_queue&lt; pair&lt;int,int&gt; , vector&lt;pair&lt;int,int&gt; &gt;,cmp2 &gt; p; int n,tmp=0,lx=0,sum[100010]; static bool cmp1(pair&lt;int,int&gt; a,pair&lt;int,int&gt; b){ if(a.first==b.first) return a.second&lt;b.second; return a.first&gt;b.first; } long long findMaximumElegance(vector&lt;vector&lt;int&gt;&gt;&amp; items, int k) { n=items.size(); for(int i=1;i&lt;=n;i++){ s[i]=make_pair(items[i-1][0],items[i-1][1]); } sort(s+1,s+1+n,cmp1); for(int i=1;i&lt;=k;i++){ if(sum[s[i].second]==0){ lx++; sum[s[i].second]=1; tmp+=s[i].first; }else{ sum[s[i].second]++; tmp+=s[i].first; p.push(make_pair(s[i].first,s[i].second)); } } tmp+=lx*lx; if(p.empty()) return tmp; for(int i=k+1;i&lt;=n;i++){ if(sum[s[i].second]){continue;} int tmp1=tmp; while(!p.empty()&amp;&amp;sum[p.top().second]&lt;=1) p.pop(); if(p.empty()) return tmp; auto t=p.top(); tmp1-=t.first; tmp1+=s[i].first; tmp1-=lx*lx; tmp1+=(lx+1)*(lx+1); if(tmp1&gt;tmp){ lx++; tmp=tmp1; p.pop(); sum[t.second]--; sum[s[i].second]++; } } return tmp; }}; 原谅我的马蜂，意思就是先按利润排序，然后先取前 个，以取前 个这个状态为基准，判断加进来一个会否会使结果变大，如果会那就取，再以这个状态为基准判断下一个，如果不会那就不取，相当于舍弃掉这个东西了 ： 1items=[[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[3,2],[3,3],[3,4],[3,5],[3,6],[3,7],[3,8],[3,9],[3,10],[3,11]] k=10 1137 正解是以前 个这个状态为下界，然后尽可能往后取不同类别的东西，答案中类别数的平方使得线性的决策不一定正确，而贪心的思想告诉我们应该尽可能取不同类别的东西，严格来说正解才能称得上是贪心 AGC064A 有点意思的构造题 leetcode 1444 预处理+dp leetcode 1388 问题转化+环形dp的经典题型，取不相邻的最值，去头去尾分别dp取最值，不然就得存到状态里 ABC315E 建反图统计 的可达点，然后按拓扑序输出 ABC315D 快学英语吧，题都看错了…… ABC315F 向后传递 题，注意不需要跳过太多点，只需要讨论跳过 个以内的点的情况，于是可以把复杂度降到","link":"/2023/08/06/%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%83/"},{"title":"最优化理论的三大非经典算法","text":"写在前面：要打数学建模，学点好玩的 模拟退火 是一个随机化算法 借鉴固体的退火过程 最核心的地方在于，对前一状态进行随机扰动，如果更优就作为当前状态，如果不优，有一定概率取为当前状态 局部最优的地方不一定全局最优，所以有一定概率从局部最优跳出，去寻找全局最优 参数有： T_begin : 初始温度 T_end : 结束温度 : 退火速率系数 T : 当前温度 以上是控制随机化过程中对状态的遍历程度完全/不完全，具体来说，每得到一个随机答案，当前温度都会乘 ，直到低于结束温度 在随机扰动时，会有 L : 马尔科夫链长度 在取答案(以越小越优为例)时，设第 个状态的答案 ，定义 如下： 在 之间随机取一个 ， 若 ，第 个状态将被接受 解决 背包问题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566% 模拟退火clear;clc;close all;N=input('有多少物品：');W=input('背包承重：');w=input('依次输入物品重量：');v=input('依次输入物品价值：');% initalpha=0.95;t_begin=200;t_end=0.1;t=t_begin;solution_new=ones(1,length(w));solution_current=zeros(1,length(w));value_current=0;value_best=0;solution_best=solution_current;counter=0;while(t&gt;t_end) counter=counter+1; for i = 1:100 index=randi([1,length(w)],1,1); solution_new(1,index)=~solution_new(1,index); solution_new.*w; % 每个位置相乘 while sum(solution_new.*w)&gt;W index=randi([1,length(w)],1,1); solution_new(1,index)=~solution_new(1,index); end value_new=sum(solution_new.*v); possibility=exp((value_new-value_current)/t); if possibility&gt;rand value_current=value_new; solution_current=solution_new; else solution_new=solution_current; end if value_current&gt;value_best value_best=value_current; solution_best=solution_current; end end value_list(counter,:)=value_best; solution_list(counter,:)=solution_best; t=t*alpha;endfigure(3);plot(value_list);xlabel('迭代次数');ylabel('目标函数值');title('适应度进化曲线');fprintf('最大价值：%f，货物重量%d\\n',value_best,sum(solution_best.*w));disp(['解：',num2str(solution_best)]);","link":"/2023/10/30/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E7%9A%84%E4%B8%89%E5%A4%A7%E9%9D%9E%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"},{"title":"牛客挑战赛48C","text":"就非得写点东西吗 题意 个点，连 条边，形成 棵树，每种方案贡献为这 棵树大小之积，求所有方案贡献和 题解 根据题意，这 棵树肯定为无根树 首先考虑要生成一棵 结点无根树，根据 序列，可以很轻松地求出方案数，如果算上每个方案的贡献，直接 就好了，答案是 发现这跟构造有根树的方案数一样，所以我们可以做一个题意转换，我们令每种方案里确定每棵树的根节点，那么方案数就跟贡献和一样了 我们假设一个虚点 ，令它连接每棵树的根节点，现在就可以算了 一共有 个点， 序列长度为 ，其中点 的度是知道的，有 ，所以在 序列中， 应该出现 次，先选 ，然后剩下的数都是在 ，再 就是答案 答案是 ，时间复杂度 代码 12345678910111213141516171819202122232425#define int long longconst int Mod=1e9+7;int n,m;int ans=1;int fpow(int a,int b){ int res=1; for(;b;b&gt;&gt;=1,a=a*a%Mod) if(b&amp;1) res=res*a%Mod; return res%Mod;}signed main(){ read(n),read(m); for(int i=1;i&lt;=m;i++) (ans*=i)%=Mod; ans=fpow(ans,Mod-2); (ans*=fpow(n,m))%=Mod; for(int i=n-m;i&lt;=n-1;i++) (ans*=i)%=Mod; cout&lt;&lt;ans&lt;&lt;endl; return 0;}","link":"/2023/10/18/newcoder48C/"},{"title":"四级作文备考","text":"写在前面：没什么好写的，就是复习作文素材 ep1 Mobile Games ​ Nowadays mobile phones have become an inseparable social networking tool for college students,which results in the popularity of mobile games.Evidently,they exert a profound impact on the life of comtemporary college students. ​ Admittedly,playing mobile games is a good way to relieve stress and anxiety.Interactive entertainment provides tangible benefits,such as hand-eye coordination,the increase in brain's activity and the boost in creativity.Also,competitve games can improve participants' team-building skills,which are essential to their academic cooperation. ​ However,playing mobile games also has negative impacts on many college students.Some would become easily addicted to mobile games due to lack of self-control.Staring at mobile screens for many hours would lead to a sedentary lifestyle,causing eyestrain or headaches.Besides,too much exposure to violent languages and scenes will likely make college students more aggressive. ​ In all,mobile games should be used in a rational way,and college students should maximize their benefits to achieve bigger success in their future life. ep2 Online Shopping ​ Buying and selling online has become important parts of many people's lives.Consumers have embraced online shopping as a cheaper and more convenient way to buy what they want.However,the fact that shopping online is not really a cheap way cannot be neglected. ​ Attracted by discount coupons or other types of overwhelming promotions,consumers tend to overspend online.Sadly,a large proportion of those items they have bought online are later found unnecessary or useless.Once consumers want to return those items,they may be required to pay a return fee.Consumers also face losses on products like fruits and vegetables,which are very unlikely to be kept 100% fresh during transportation.Moreover,to achieve higher sales,unscrupulous businesses may display misleading,exaggerated and fraudulent information,leading to a higher risk of fraud and a huge loss of money for consumers. ​ Therefore,to enjoy a truly lower price of online products,we should go through websites carefully,and think twice before we choose to pay for the products.","link":"/2023/08/08/%E8%8B%B1%E8%AF%AD%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","link":"/tags/Atcoder/"},{"name":"AppleScript","slug":"AppleScript","link":"/tags/AppleScript/"},{"name":"CodeForces","slug":"CodeForces","link":"/tags/CodeForces/"},{"name":"思维题","slug":"思维题","link":"/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"集训","slug":"集训","link":"/tags/%E9%9B%86%E8%AE%AD/"},{"name":"数学建模","slug":"数学建模","link":"/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"life","slug":"life","link":"/tags/life/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"tarjan","slug":"tarjan","link":"/tags/tarjan/"},{"name":"生成树","slug":"生成树","link":"/tags/%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"prufer序列","slug":"prufer序列","link":"/tags/prufer%E5%BA%8F%E5%88%97/"},{"name":"Matlab","slug":"Matlab","link":"/tags/Matlab/"},{"name":"模拟退火","slug":"模拟退火","link":"/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"},{"name":"遗传算法","slug":"遗传算法","link":"/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"},{"name":"神经网络","slug":"神经网络","link":"/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"计数题","slug":"计数题","link":"/tags/%E8%AE%A1%E6%95%B0%E9%A2%98/"},{"name":"English","slug":"English","link":"/tags/English/"}],"categories":[]}