<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="wsy_jim"><title>CMU15445学习笔记 · M-071的甲板</title><meta name="description" content="学一学CMU的15445

Projects #0 - C++ Primer
C++ Bootcamp
主要针对 C++17 特性，共  个文件。

references.cpp
有关引用（别名），函数传引用
move_semantics.cpp
有关移动语义和右值引用

lvalue（左值）：re"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.png"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li><li> <a href="/links">友链</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/logo.jpg"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo.jpg" style="width:220px;" alt="favicon"><h3 title=""><a href="/">M-071的甲板</a></h3><div class="description"><p>A clean circle,a regular life,a simple love.</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/wsyunine"><i class="fa fa-github"></i></a></li><li><a href="mailto:wsyjim.0bb0@gmail.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=3340307001"><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://www.weibo.com/u/6600856981"><i class="fa fa-weibo"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> wsy_jim</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>CMU15445学习笔记</a></h3></div><div class="post-content"><p><p>学一学CMU的15445</p>
<span id="more"></span>
<h2 id="projects-0---c-primer">Projects #0 - C++ Primer</h2>
<h3 id="c-bootcamp">C++ Bootcamp</h3>
<p>主要针对 C++17 特性，共 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 1000 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z" transform="translate(500,0)"></path></g></g></g></svg></mjx-container></span> 个文件。</p>
<ol type="1">
<li><p>references.cpp</p>
<p>有关引用（别名），函数传引用</p></li>
<li><p>move_semantics.cpp</p>
<p>有关移动语义和右值引用</p>
<ul>
<li><p>lvalue（左值）：refer to 内存中某个有权限访问的区域的对象</p>
<p>rvalue（右值）：非左值的值，数据位于的区域没有权限访问（字面常量）或者没有必要访问（匿名对象），包括<strong>将亡值</strong>和<strong>纯右值</strong></p>
<p>赋值语句中等号左边的必须是左值，右边的随便</p></li>
<li><p>左值引用（&amp;）和右值引用（&amp;&amp;）都必须立即初始化，右值引用可以<strong>通过移动的方式在浅拷贝的情况下保证拷贝的安全性</strong>，在设计和实现类时，对于需要动态申请大量资源的类，应该设计右值引用的拷贝构造函数和赋值函数，以提高应用程序的效率，具体 3. 中有讲</p></li>
<li><p>std::move() 方法可以将左值转换为右值，即将亡值，方便使用移动语义，需要 <code>&lt;utility&gt;</code> 头文件</p></li>
</ul></li>
<li><p>move_constructors.cpp</p>
<p>有关应用移动语义的拷贝构造函数和赋值重载函数</p>
<p>在类定义中删除左值引用的拷贝构造函数和赋值重载函数，意味着实例化后就不再允许被复制，防止双重删除或者内存泄露</p>
<p>References：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/677643121">C++11右值引用|移动语义|完美转发|巨巨巨详细</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/620583555">C++|左值、右值、将亡值|谈谈我对它们的深入理解</a></li>
</ul></li>
<li><p>templated_functions.cpp</p>
<p>有关模板函数</p>
<p>注意模板参数不一定要是 <code>class</code> 或者 <code>typename</code>，也可以是别的，但没必要</p></li>
<li><p>templated_classes.cpp</p>
<p>有关模板类</p></li>
<li><p>wrapper_class.cpp</p>
<p>有关包装类</p>
<ul>
<li>RAII（Resource Acquisition is Initialization）：一个实例化管理一个资源，防止双重删除或内存泄露</li>
<li>使用移动语义</li>
</ul></li>
<li><p>iterator.cpp</p>
<p>有关迭代器，实现了一个双向链表（DLL）及其迭代器</p></li>
<li><p>namespaces.cpp</p>
<p>有关命名空间</p></li>
<li><p>vectors.cpp</p>
<p>有关动态数组</p>
<p><code>std::remove_if()</code> 不能删除元素，只能将元素移到末尾，配合 <code>erase()</code> 函数才能删掉</p>
<p><code>emplace_back()</code> 比 <code>push_back()</code> 稍快</p></li>
<li><p>sets.cpp</p>
<p>有关集合</p>
<p><code>count()</code> 函数</p></li>
<li><p>unordered_maps.cpp</p>
<p>有关映射</p>
<p><code>count()</code> 函数</p></li>
<li><p>auto.cpp</p>
<p>有关 <code>auto</code> 类型使用</p></li>
<li><p>unique_ptr.cpp</p>
<p>有关智能指针类型 <code>unique_ptr</code> 使用</p>
<ul>
<li><p>需要 <code>&lt;memory&gt;</code> 头文件</p></li>
<li><p><code>unique_ptr</code> 保留对象的唯一所有权，没有两个 <code>unique_ptr</code> 指针指向同一个对象</p></li>
<li><p>初始化</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用make_unique&lt;&gt;()方法初始化，调用的构造函数是&lt;&gt;类型的构造函数</span></span><br><span class="line">std::unique_ptr&lt;Point&gt; u = std::<span class="built_in">make_unique</span>&lt;Point&gt;();</span><br></pre></td></tr></table></figure></p></li>
<li><p>可以通过移动语义转移所有权</p></li>
</ul></li>
<li><p>shared_ptr.cpp</p>
<p>有关智能指针类型 <code>shared_ptr</code> 使用</p>
<ul>
<li><p>需要 <code>&lt;memory&gt;</code> 头文件</p></li>
<li><p>可以有多个 <code>shared_ptr</code> 指针指向同一个对象</p></li>
<li><p>初始化</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用make_shared&lt;&gt;()方法初始化，调用的构造函数是&lt;&gt;类型的构造函数</span></span><br><span class="line">std::shared_ptr&lt;Point&gt; u = std::<span class="built_in">make_shared</span>&lt;Point&gt;();</span><br></pre></td></tr></table></figure></p></li>
<li><p>通过 <code>use_count()</code> 方法可以得到有多少个指针指向同个对象</p></li>
<li><p>可以通过移动语义转移所有权</p></li>
</ul></li>
<li><p>mutex.cpp</p>
<p>有关互斥锁</p>
<ul>
<li>同步原语（Synchronization Primitives）是用于支持此多线程环境下线程同步的工具和机制。这些源于主要用于管理线程之间对共享资源的访问，防止数据竞争和保证线程安全</li>
<li><code>std::mutex</code> 提供独占锁，确保同一时间只有一个线程可以获得互斥量，不可复制，不可移动</li>
<li>互斥量状态：
<ul>
<li>解锁状态意味着共享资源可用</li>
<li>加锁状态意味着共享资源不可用</li>
</ul></li>
<li>需要 <code>&lt;mutex&gt;</code> 和 <code>&lt;thread&gt;</code> 头文件</li>
<li><code>lock()</code> 锁住互斥量，<code>unlock()</code> 解锁互斥量，<code>try_lock()</code> 尝试锁住互斥量</li>
<li>被阻塞</li>
</ul>
<p>References：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_74811378/article/details/144144933">C++多线程——互斥量mutex</a></li>
</ul></li>
<li><p>scoped_lock.cpp</p>
<p>有关多个互斥量的管理</p>
<ul>
<li><p>需要 <code>&lt;mutex&gt;</code> 和 <code>&lt;thread&gt;</code> 头文件</p></li>
<li><p>当创建一个 <code>std::scoped_lock</code> 对象时，它尝试取得其所给互斥量的所有权。当控制权离开创建 <code>scoped_lock</code> 对象的作用域时，<code>scoped_lock</code> 会被析构，互斥量随之被释放。如果给定了多个互斥量，将使用避免死锁的算法，类似于 <code>std::lock</code></p></li>
<li><p>是一个 RAII 风格的类</p></li>
<li><p><code>scoped_lock</code> 类不可复制，不可移动</p></li>
</ul>
<p>References：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21438461/article/details/135670987">【C++ 17 新特性 互斥锁】std::scoped_lock 的使用，管理多个互斥量</a></li>
</ul></li>
<li><p>condition_variable.cpp</p>
<p>有关条件变量</p>
<ul>
<li>需要 <code>&lt;condition_variable&gt;</code> 头文件</li>
<li>功能：
<ul>
<li>拥有条件变量的线程获取互斥量</li>
<li>循环检查某个条件，如果条件不满足则阻塞直到满足；如果满足则向下执行</li>
<li>某个线程满足条件执行完之后调用 <code>notify_one</code> 或 <code>notify_all</code> 唤醒一个或所有等待线程</li>
</ul></li>
<li><code>wait()</code> 第一个参数必须用 <code>unique_lock</code></li>
<li><code>unique_lock</code> 不能复制，可以移动</li>
</ul>
<p>References：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/599172163">C++11条件变量condition_variable详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013043408/article/details/138437356">【C++】独占互斥锁（unique_lock）</a></li>
</ul></li>
<li><p>rwlock.cpp</p>
<p>有关读写器锁的用法</p>
<ul>
<li>用 <code>std::shared_mutex</code>、<code>std::shared_lock</code> 和 <code>std::unique_lock</code></li>
<li>需要 <code>&lt;shared_mutex&gt;</code></li>
<li><code>std::mutex</code> 和 <code>std::shared_mutex</code> 的区别：
<ul>
<li><code>std::mutex</code> 提供独占访问，同一时间只能有一个线程持有该类型的锁</li>
<li><code>std::shared_mutex</code> 提供共享访问和独占访问，允许多个线程通过持有 <code>std::shared_lock</code> 共享锁来只读访问，允许一个线程持有 <code>std::unique_lock</code> 独占锁来进行写操作，但是共享锁和独占锁不能同时存在，互斥</li>
<li><code>std::shared_mutex</code> 更适用于读多写少的场景</li>
</ul></li>
</ul></li>
<li><p>s24_my_ptr.cpp</p>
<p>实现了一个 <code>std::unique_pointer&lt;T&gt;</code> 类</p>
<ul>
<li>使用原始指针类型，很可能会出现内存泄露，二次释放，释放后访问的问题</li>
<li>RAII 的好处</li>
<li><code>smart_generator&lt;int&gt;()</code> 和 <code>dumb_generator&lt;int&gt;()</code> 的区别</li>
</ul></li>
</ol>
<h3 id="hyperloglog-算法">HyperLogLog 算法</h3>
<p>HyperLogLog 算法是一种用于估计大规模数据集基数的随机化算法</p>
<p>基数（cardinality）：集合中不同元素的个数</p>
<p>时间复杂度： - <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span> 插入 - <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span> 查询 - <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span> 合并两个计数器</p>
<p>基本原理：</p>
<p>基于抛硬币的原理，由连续抛硬币出现正面的概率来估算一共抛硬币的次数</p>
<p>相似的，我们可以将主键进行哈希，得到一个 01 串，通过统计从第零位开始连续的 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></svg></mjx-container></span> 的个数的最大值来估算基数</p>
<p>为了减小偶然性，可以设置 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 878 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span> 个寄存器，分别统计连续 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></svg></mjx-container></span> 的个数的最大值，取01串的前 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></svg></mjx-container></span> 高位作为寄存器编号，分别在各自寄存器内更新，最后综合起来计算答案即可</p>
<p>Presto 的实现其实就是为了减小寄存器（dense_bucket_）的大小，将超出寄存器表示范围的部分存到另一个 unordered_map（overflow_bucket_）中，因为有时某些寄存器根本没有用到，无用空间过多</p>
<p><img src="https://p.ipic.vip/9v9etd.png" alt="image-20250110153509098" style="zoom:70%;"></p>
<p>上图是我瞎写了一通以后拿的分数，看了看 results 发现答案没问题，但是存在内存泄露，因为我寄存器是用动态分配空间的数组实现的，这就需要在类析构的时候 <code>free()</code> 掉，写了一个析构函数就过了，如果使用 STL​ 中的 <code>vector</code> 就不会出现内存泄露，因为 C++ 的 STL 都遵循 RAII 的原则</p>
<p><img src="/Users/wsy/Library/Application%20Support/typora-user-images/image-20250110162252511.png" alt="image-20250110162252511" style="zoom:70%;"></p>
<p>还有一个比较蛋疼的地方就是格式问题，格式不对就给判成 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></svg></mjx-container></span> 分，需要注意一下</p>
</p><div class="tip">本文采用CC-BY-SA-3.0协议，转载请注明出处<br>作者: wsy_jim</div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2024-12-09</span><i class="fa fa-tag"></i><a class="tag" href="/tags/CMU/" title="CMU">CMU </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Databases/" title="Databases">Databases </a><span class="leancloud_visitors"></span><span>大约2002个字, 6分钟40秒读完</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://wsyunine.github.io/2024/12/09/CMU15445-learning-note/,M-071的甲板,CMU15445学习笔记,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2024/12/27/better-terminal/" title="更好的终端模组">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2024/12/04/Mysql-learning-2/" title="MySQL 学习笔记进阶篇">下一篇</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>