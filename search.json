[{"title":"两种项目编译方式及其延伸","url":"/2025/01/12/shell-learning/","content":"\ntsoding 大大写项目用 `shell` 脚本+ `clang` 来编译，CMU15445 的 Bustub 项目用 `CMake` 来编译，我来简单搜集信息\n\n<!--more-->\n\n## Shell\n\nGUI -- 用户图形界面\n\nCLI -- 命令行界面\n\nShell 相当于用户与操作系统之间的中介\n\nMore Infomation: [Shell 编程范例](https://tinylab-1.gitbook.io/shellbook) \n\n更加系统的学习，推荐：[The Linux Command Line](https://billie66.github.io/TLCL/book/index.html) \n\n### 脚本的运行\n\n假设我编写好了一个脚本 `test.sh`，先给该文件可执行权限：\n\n```Shell\nchmod +x test.sh\n```\n\n然后执行即可\n\n```Shell\ntest.sh\n```\n\n或是直接\n\n```SHell\nbash test.sh\n```\n\n```\nsource test.sh\n```\n\n```\n. test.sh\n```\n\n### 脚本的编写\n\n脚本开头\n\n```shell\n#!/bin/bash\n```\n\n用于指定该脚本的解释器\n\n剩下编译的部分\n\n```shell\ng++ -std=c++17 -o [filename] [filename].cpp\n```\n\n就好了\n\n如果还有更复杂的要求可以问 GPT\n\nGPT 写的一个脚本\n\n```SHELL\n#!/bin/bash\n\n# 设置编译器和编译选项\nCXX=g++\nCXXFLAGS=\"-std=c++17 -O2 -Wall\"\nOUTPUT=\"program\"\n\n# 定义源文件和目标文件\nSRC_DIR=\"src\"\nSRC_FILES=$(find $SRC_DIR -name \"*.cpp\")\nOBJ_FILES=\"\"\n\n# 编译每个源文件为目标文件\nfor src in $SRC_FILES; do\n    obj=\"${src%.cpp}.o\"\n    $CXX $CXXFLAGS -c $src -o $obj\n    OBJ_FILES=\"$OBJ_FILES $obj\"\ndone\n\n# 链接目标文件生成可执行文件\n$CXX $OBJ_FILES -o $OUTPUT\n\n# 清理目标文件（可选）\nrm -f $OBJ_FILES\n\necho \"编译完成，生成可执行文件：$OUTPUT\"\n```\n\n`g++` 的 `-c` 是仅编译不连接，生成 `.o` 文件\n\n### \\$ 在 Shell 中的用法\n\n1. 用于变量引用\n\n    ```shell\n    $ name=\"John\"\n    $ echo $name\n    John\n    $ echo \"Hello, ${name}Doe\"\n    Hello, JohnDoe\n    ```\n\n2. 用于命令替换\n\n    ```shell\n    $ current_date=$(date)\n    $ echo \"Today is $current_date\"\n    Today is Sat Jan 12 12:34:56 UTC 2025\n    ```\n\n3. 用于表示一些参数\n\n    `$0` 表示当前脚本的名称\n\n    `$1`, `$2`,... 表示脚本的参数\n\n    `$#` 表示参数个数\n\n    `$?` 表示上一个命令的退出状态码（0 表示成功）\n\n## CMake\n\n`cmake` 可以自动构建 Makefile，所以这个编译过程分为两个过程，先构建 Makefile 文件，再 `make` \n\n`CMakeLists.txt` 是配置文件\n\n### 构建过程\n\n```shell\ncmake -B build # 生成构建目录\ncmake --build build # 执行构建\n./build/project_name # 运行可执行文件\n```\n\n### 一些语法\n\n基本的三个东西：\n\n```cmake\n# 最低支持版本\ncmake_minimum_required(VERSION 3.10)\n# 项目名称\nproject(project_name)\n# 添加可执行文件\n# 头文件会自动在当前文件夹里找 第一个参数是 target 后面的参数是 dependency\nadd_executable(project_name pro1.cpp pro2.cpp)\n```\n\n添加库目标，可多次复用\n\n```cmake\nadd_library(lib_name STATIC lib.cpp)\nadd_executable(project pro.cpp)\n# 链接库\ntarget_link_libraries(project lib_name)\n```\n\n子目录中也有 CMakelist.txt，对子目录运行 CMake\n\n```cmake\nadd_subdirectory(dir_name)\n```\n\n若头文件被装到了一个子文件夹中，下面的语句给库头文件支持，`PUBLIC` 表示这些头文件可以被任何依赖该库的文件通过 `#include<当前文件夹名/头文件名>` 引用\n\n```cmake\ntarget_include_directories(lib_name PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include)\n```\n\n打印调试信息\n\n```cmake\nmessage(STATUS \"Current source dir: ${CMAKE_CURRENT_SOURCE_DIR}\")\n```\n\n别的问 GPT\n\n## e.g. 1\n\n记录我构建做算法题的工作流的过程\n\n我的一个基本的文件布局\n\n```\n/ACM/2025/\n├── 001/\n│   ├── CSP-S2024\n│   |   ├── A.cpp\n|   |   ├── B.cpp\n|   |   ├── C.cpp\n|   |   └── D.cpp\n│   └── NOIP2024\n├── 002/\n├── 003/\n├── aliases.sh\n└── run_code.sh\n```\n\n默认用的 shell 是 zsh，可以拿 `echo $SHELL` 查看\n\nzsh 的配置文件在 `~/.zshrc` \n\n`aliases.sh` 是用来定义函数和别名的，方便编译运行文件\n\n`run_code.sh` 是编译并运行 `.cpp` 文件的脚本\n\n```shell\n# aliases.sh\n#!/bin/zsh\n\nacm() {\n    if [ $# -lt 2 ]; then\n        echo \"Please input the correct parameters: \"\n        echo \"  acm np [folder_name] [create_file_quantity]\"\n        echo \"  acm run [cpp_file_name]\"\n        return 1\n    fi\n    identifier=$1        # 标识符（如 np）\n    if [ \"$identifier\" = \"np\" ]; then\n        if [ $# -ne 3 ]; then\n            echo \"Please input the correct parameters: \"\n            echo \"  acm np [folder_name] [create_file_quantity]\"\n            echo \"  acm run [cpp_file_name]\"\n            return 1\n        fi  \n        folder_name=$2       # 新建文件夹名\n        cpp_count=$3         # 要创建的 cpp 文件数量（如 3）\n        # 检查参数3是否是有效数字\n        if ! [[ \"$cpp_count\" =~ ^[0-9]+$ ]] || [ \"$cpp_count\" -le 0 ]; then\n            echo \"请输入有效的数字参数！\"\n            return 1\n        fi\n        # 获取当前目录下按时间排序的文件夹，选择最新的一个\n        # 查找符合条件的 3 位数字文件夹\n        latest_folder=$(find . -maxdepth 1 -type d | grep -E './[0-9]{3}$' | xargs -I {} stat -f \"%m %N\" {} | sort -n | tail -n 1 | awk '{print $2}')\n        latest_folder=$(basename \"$latest_folder\") # 提取文件夹名\n        latest_folder=\"${latest_folder}/\" # 确保添加尾部斜杠\n        if [ -z \"$latest_folder\" ]; then\n            echo \"当前目录下没有文件夹！\"\n            return 1\n        fi\n        # 在最新文件夹下创建目标文件夹\n        target_folder=\"${latest_folder}${folder_name}\"\n        # 如果目标文件夹不存在，则创建它\n        if [ ! -d \"$target_folder\" ]; then\n            mkdir \"$target_folder\"\n            echo \"创建文件夹 $target_folder\"\n        fi\n        # 在目标文件夹中创建指定数量的 cpp 文件\n        for i in $(seq 1 $cpp_count); do\n            # 获取字母序列 A、B、C...\n            letter=$(printf \\\\$(printf '%03o' $((65 + i - 1))))\n            touch \"${target_folder}/${letter}.cpp\"\n            echo \"${letter}.cpp 创建完成\"\n        done\n        echo \"操作完成！\"\n    elif [ \"$identifier\" = \"run\" ]; then\n        if [ $# -ne 2 ]; then\n            echo \"Please input the correct parameters: \"\n            echo \"  acm np [folder_name] [create_file_quantity]\"\n            echo \"  acm run [cpp_file_name]\"\n            return 1\n        fi\n        /Users/wsy/Back_end/ACM/2025/run_code.sh $2\n    else \n        echo \"Please input the correct parameters: \"\n        echo \"  acm np [folder_name] [create_file_quantity]\"\n        echo \"  acm run [cpp_file_name]\"\n        return 1\n    fi\n}\n```\n\n```shell\n# run_code.sh\n#!/bin/bash\n\n# 检查是否提供了参数\nif [ \"$#\" -ne 1 ]; then\n    echo \"Usage: $0 <source_file>\"\n    exit 1\nfi\n\n# 获取传入的文件路径\nSOURCE_FILE=\"$1\"\n\n# 检查文件是否存在\nif [ ! -f \"$SOURCE_FILE\" ]; then\n    echo \"Error: File '$SOURCE_FILE' does not exist.\"\n    exit 1\nfi\n\n# 提取文件目录和文件名（不带扩展名）\nDIR=$(dirname \"$SOURCE_FILE\")\nBASE_NAME=$(basename \"$SOURCE_FILE\" .cpp)\n\n# 设置输出的可执行文件路径（无后缀）\nOUTPUT_FILE=\"$DIR/$BASE_NAME\"\n\n# 编译源文件\necho \"Compiling '$SOURCE_FILE'...\"\ng++ -o \"$OUTPUT_FILE\" \"$SOURCE_FILE\"\n\n# 检查编译是否成功\nif [ \"$?\" -ne 0 ]; then\n    echo \"Error: Compilation failed.\"\n    exit 1\nfi\n\n# 执行生成的可执行文件\necho \"Executing '$OUTPUT_FILE'...\"\n\ntouch \"${OUTPUT_FILE}.out\"\n\n# 这里我将输出重定向到 .out 文件中再输出，解决了输入输出乱套的情况\n\"$OUTPUT_FILE\" >\"${OUTPUT_FILE}.out\"\necho \"Output:\"\ncat \"${OUTPUT_FILE}.out\"\n\n```\n\nGPT 写的脚本就是安全可靠\n\n因为 `aliases.sh` 定义的别名只有在 `source` 后才会适用，我们希望每次进入这个文件夹后就可以使用 `run` 命令了，这个需要动态加载 `aliases.sh` 文件，在 `.zshrc` 中利用 chpwd 钩子（每次切换目录的时候会执行）动态加载 `aliases.sh` \n\n```shell\n# .zshrc\n\n# 定义函数，用于寻找并加载 aliases.sh\nfunction load_aliases() {\n    local dir=$(pwd)\n    while [ \"$dir\" != \"/\" ]; do\n        if [ -f \"$dir/aliases.sh\" ]; then\n            source \"$dir/aliases.sh\"\n            return\n        fi\n        dir=$(dirname \"$dir\")\n    done\n}\n\n# 使用 chpwd 钩子，每次目录切换时执行 load_aliases\nfunction chpwd() {\n    load_aliases\n}\n\n# 初始加载，确保第一次打开 shell 时也加载\nload_aliases\n\n```\n\n结合上我之前写过的 nvim 配置，这样的话就可以完整的构建一个做算法题时编译运行的工作流了，我发现这个 CLI 具有高度的定制化，是时候将 GUI 迁移到 CLI 了","tags":["shell","cmake"],"categories":["开发"]},{"title":"更好的终端模组","url":"/2024/12/27/better-terminal/","content":"\n改善 MacOS Terminal 的外观以及实用性，主要贴出来一些 *References*，以后还需要再配置一遍，这次配置得好乱，花了两三天，也不知道写得全不全\n\n<!--more-->\n\n## 用 Wezterm 代替 Terminal\n\n```shell\nbrew install wezterm\n```\n\n在 `~/.config/wezterm/wezterm.lua` 里配置\n\n配置文档：[LINK](https://wezfurlong.org/wezterm/config/files.html) \n\nB站上搬运的教程：[LINK](https://www.bilibili.com/video/BV1miWMe9Esq/?spm_id_from=333.337.search-card.all.click&vd_source=4f5fdb95c437ce1caa54cd65376ba63a) \n\n暂时配成这样，不太愿意加图：\n\n```lua\nlocal wezterm = require(\"wezterm\")\n\nconfig = wezterm.config_builder()\n\nconfig = {\n\tautomatically_reload_config = true,\n\tenable_tab_bar = false,\n\twindow_close_confirmation = \"NeverPrompt\",\n\twindow_decorations = \"RESIZE\",\n\tdefault_cursor_style = \"BlinkingBar\",\n\tcolor_scheme = \"Nord (Gogh)\",\n\tfont = wezterm.font(\"Fira Code\", { weight = \"Bold\" }),\n\tfont_size = 15,\n\tbackground = {\n\t\t{\n\t\t\tsource = {\n\t\t\t\tColor = \"#282c35\",\n\t\t\t},\n\t\t\twidth = \"100%\",\n\t\t\theight = \"100%\",\n\t\t\topacity = 0.85,\n\t\t},\n\t},\n\twindow_padding = {\n\t\tleft = 30,\n\t\tright = 30,\n\t\ttop = 30,\n\t\tbottom = 30,\n\t},\n}\n\nreturn config\n```\n\n![image-20241227194724776](https://p.ipic.vip/p8kkmx.png)\n\n等寒假有时间了设计一下\n\n添加了代码高亮和代码补全的插件，b站视频有讲，需要在 `.zshrc` 里配置：\n\n```\nsource $(brew --prefix)/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\n\n(( ${+ZSH_HIGHLIGHT_STYLES} )) || typeset -A ZSH_HIGHLIGHT_STYLES\nZSH_HIGHLIGHT_STYLES[path]=none\nZSH_HIGHLIGHT_STYLES[path_prefix]=none\n\nsource $(brew --prefix)/share/zsh-autosuggestions/zsh-autosuggestions.zsh\n```\n\nwezterm 的上下分屏：`Ctrl + Option + %` \n\nwezterm 的左右分屏：`Ctrl + Option + \"` \n\n光标切屏：`Ctrl + Shift + 方向键` \n\n一般就使用 tmux 的分屏比较好，上面的难记\n\n## 用 Neovim 搭建 PDE\n\n费老劲学 `vim`，还得练\n\n```\nbrew install nvim\n```\n\n有图形化界面，还不错，外观还需要配置\n\n参考：[LINK](https://www.bilibili.com/video/BV1vcWXe4Evf?spm_id_from=333.788.videopod.sections&vd_source=4f5fdb95c437ce1caa54cd65376ba63a) \n\n上下分屏：`split` \n\n左右分屏：`vs` \n\n光标切屏：`Ctrl + h j k l` \n\n我把 Lazyvim 的背景设成透明了\n\n## 添加插件\n\n参考：[LINK](https://www.youtube.com/watch?v=mmqDYw9C30I) \n\n### thefuck\n\n一个可以帮你修改打错的命令的插件，一旦你打错了一个命令，你就可以接着一句 `fuck`，它就会自己帮你改对\n\n在 `.zshrc` 中配置（alias可以改别名）：\n\n```\neval $(thefuck --alias)\neval $(thefuck --alias fk)\n```\n\n### eza\n\n更好的 `ls`，在 `.zshrc` 文件中配置（用 `eza` 替换 `ls`）：\n\n```\nalias ls=\"eza --color=always --long --git --no-filesize --icons=always --no-time --no-user --no-permissions\"\n```\n\n### tldr\n\n告诉你这个关键字有一些什么有趣有用的用法\n\n### zoxide\n\n更好的 `cd`，在 `.zshrc` 文件中配置：\n\n```\neval \"$(zoxide init zsh)\"\n```\n\n会记住你进过的文件夹，再进就不用一个一个 `cd` 了，如果有多个满足条件，空格 + Tab 选文件夹\n\n### powerlevel10k\n\n一个终端主题，蛮好看\n\n## 用 tmux 管理多个 Terminal\n\n参考：[LINK](https://www.youtube.com/watch?v=U-omALWIBos) \n\n配置文件（`~/.tmux.conf`）：\n\n```\nset -g default-terminal \"tmux-256color\"\n\n\nset -g prefix C-a\nunbind C-b\nbind-key C-a send-prefix\n\nunbind %\nbind | split-window -h\n\nunbind '\"'\nbind - split-window -v\n\nunbind r\nbind r source-file ~/.tmux.conf\n\nbind -r j resize-pane -D 5\nbind -r k resize-pane -U 5\nbind -r l resize-pane -R 5\nbind -r h resize-pane -L 5\n\nbind -r m resize-pane -Z\n\nset -g mouse on\n\nset-window-option -g mode-keys vi\n\nbind-key -T copy-mode-vi 'v' send -X begin-selection\nbind-key -T copy-mode-vi 'y' send -X copy-selection\n\nunbind -T copy-mode-vi MouseDragEnd1Pane\n\n# tpm plugin\nset -g @plugin 'tmux-plugins/tpm'\n\n# list of tmux plugins\nset -g @plugin 'christoomey/vim-tmux-navigator'\nset -g @plugin 'jimeh/tmux-themepack'\nset -g @plugin 'tmux-plugins/tmux-resurrect'\nset -g @plugin 'tmux-plugins/tmux-continuum'\n\nset -g @themepack 'powerline/default/cyan'\n\nset -g @resurrect-capture-pane-contents 'on'\nset -g @continuum-restore 'on'\n\nset -g @vim_navigator_mapping_left \"C-Left C-h\"  # use C-h and C-Left\nset -g @vim_navigator_mapping_right \"C-Right C-l\"\nset -g @vim_navigator_mapping_up \"C-k\"\nset -g @vim_navigator_mapping_down \"C-j\"\nset -g @vim_navigator_mapping_prev \"\"  # removes the C-\\ binding\n\nset -g @vim_navigator_prefix_mapping_clear_screen \"\"\n\nset -g xterm-keys on\n\nrun '~/.tmux/plugins/tpm/tpm'\n```\n\n快捷键：\n\n- 魔法前摇：`Ctrl + a` \n- 上下分屏：`-` \n- 左右分屏：`|` \n- 光标切屏：`Ctrl + h j k l` \n- 配置更新：`r` \n- 改变分屏大小：`h j k l` \n- 分屏窗口最大化/最小化：`m` \n- vi 风格移动光标和页面\n- 安装插件：`I` \n- 新建窗口：`c` \n- 切换窗口：窗口代号\n- 窗口重命名：`,` \n- 切换到相邻窗口：`p n` \n- 切换到相邻终端：`( )`  \n- 窗口及终端信息：`w` \n- 退出复制模式：`Ctrl + C` \n\n## Neovim 配置 C++ 编译环境\n\n一些理论：[LINK](https://zhuanlan.zhihu.com/p/643033884) \n\n要装插件还是得先学习 `lazyvim` 的结构：[LINK](https://lazyvim-ambitious-devs.phillips.codes/) \n\n- `LSP`、代码补全、代码高亮和结构解析、编译器\n\n之前用 `VScode` 装过，不用再次装\n\n- 代码片段用 `luasnip` \n\n参考：[LINK](https://www.youtube.com/watch?v=Vr7A90_tSns&list=PL0EgBggsoPCnZ3a6c0pZuQRMgS_Z8-Fnr) \n\n我用 `<c-u>` 替换了 `<c-i>` 因为其哈希值与 `<Tab>` 相同，缩进就用不了了\n\n- 代码格式化用 `clang-format` \n\n在 `init.lua` 中配置：\n\n```\nvim.opt.tabstop = 4 -- 实际 Tab 字符宽度\nvim.opt.shiftwidth = 4 -- 缩进宽度\nvim.opt.expandtab = true -- 用空格代替 Tab\n```\n\n- 调试用 `dap` \n\n参考：[LINK](https://github.com/mfussenegger/nvim-dap?tab=readme-ov-file) \n\n- 另外设置了快捷键 `<leader>r` 普通编译以及 `<leader>R` 调试编译\n- 添加了 `vim-tmux-navigator` 插件，让窗口切换可以横跨 tmux 和 nvim\n- 切换了 `catppuccin` 主题\n- 待添加：git 相关插件以及 [AI 支持](https://github.com/Kurama622/llm.nvim/tree/main) \n\n![image-20241229125239973](https://p.ipic.vip/dnqvex.png)\n","tags":["MacOS","Terminal"],"categories":["系统"]},{"title":"CMU15445作业","url":"/2024/12/09/CMU15445-learning-note-hwk/","content":"\n学一学CMU的15445，[课程地址](https://15445.courses.cs.cmu.edu/fall2024/) \n\n<!--more-->\n\n## Homework #1 - SQL\n\n要求在 `SQLite` 和 `Duckdb` 上编写一些查询代码并执行，还是有些难度的\n\n1. 查询至少得过一枚奖牌的教练（即相同国家和项目的运动员或队伍得过至少一枚奖牌的教练），并按以奖牌数为第一关键字降序、以名字为第二关键字字典序排序\n\n    分析：\n\n    首先我们要找出教练的国家和项目\n\n    ```SQL\n    select ch.name, ch.country_code, ch.discipline from coaches as ch;\n    ```\n\n    然后要找出奖牌的项目和胜者 code\n\n    ```SQL\n    select m.discipline, m.winner_code from medals as m;\n    ```\n\n    将两者通过 discipline 结合\n\n    ```SQL\n    select ch.name as ch_name, ch.country_code as ch_ct, m.winner_code as win from coaches as ch, medals as m where ch.discipline = m.discipline;\n    ```\n\n    先找运动员\n\n    ```SQL\n    select tmp.ch_name, count(*) as c\n    from (select ch.name as ch_name, ch.country_code as ch_ct, m.winner_code as win from coaches as ch, medals as m where ch.discipline = m.discipline) as tmp, athletes as a\n    where tmp.win = a.code and tmp.ch_ct = a.country_code\n    group by tmp.ch_name\n    having c > 0;\n    ```\n\n    再找队伍\n\n    这个地方需要注意，队伍 relation 中一个 tuple 表示一个队员，所以一个队伍可能会有很多 tuple，我们需要的只是 code 和 country_code，所以需要子查询\n\n    ```SQL\n    select code, country_code from teams group by code;\n    ```\n\n    一个很有意思的事情，在 `SQLite` 中，上面的语句是可以正常执行的，但是在 `Duckdb` 中会报错，因为机器不知道 `code` 和 `country_code` 之间存在关系，即不同的 `code` 对应不同的 `country_code`，所以若只以 `code` 分组会导致机器不知道要拿组内哪个 `country_code` 的值来输出，产生不准确的查询，要么也以 `country_code` 分组，要么加 `any_value()` 函数，表示随意取一个值，但是在 `SQLite` 中，没有这个函数\n\n    ```SQL\n    select code, any_value(country_code) from teams group by code;\n    ```\n\n    ```SQL\n    select tmp.ch_name, count(*) as c\n    from (select ch.name as ch_name, ch.country_code as ch_ct, m.winner_code as win from coaches as ch, medals as m where ch.discipline = m.discipline) as tmp, (select code, country_code as ct from teams group by code) as t\n    where tmp.win = t.code and tmp.ch_ct = t.ct\n    group by tmp.ch_name\n    having c > 0;\n    ```\n\n    最后排序（丑的一批）\n\n    ```SQL\n    -- SQLite\n    select q1.name, sum(c) as s\n    from \n    \t(\n            select tmp.ch_name as name, count(*) as c\n            from (select ch.name as ch_name, ch.country_code as ch_ct, m.winner_code as win from coaches as ch, medals as m where ch.discipline = m.discipline) as tmp, athletes as a\n            where tmp.win = a.code and tmp.ch_ct = a.country_code\n            group by tmp.ch_name\n            having c > 0\n        union all\n            select tmp.ch_name as name, count(*) as c\n            from (select ch.name as ch_name, ch.country_code as ch_ct, m.winner_code as win from coaches as ch, medals as m where ch.discipline = m.discipline) as tmp, (select code, country_code as ct from teams group by code) as t\n            where tmp.win = t.code and tmp.ch_ct = t.ct\n            group by tmp.ch_name\n            having c > 0\n        ) as q1\n    group by q1.name\n    order by s desc, q1.name;\n    ```\n\n    ```SQL\n    -- Duckdb\n    select q1.name, sum(c) as s\n    from \n    \t(\n            select tmp.ch_name as name, count(*) as c\n            from (select ch.name as ch_name, ch.country_code as ch_ct, m.winner_code as win from coaches as ch, medals as m where ch.discipline = m.discipline) as tmp, athletes as a\n            where tmp.win = a.code and tmp.ch_ct = a.country_code\n            group by tmp.ch_name\n            having c > 0\n        union all\n            select tmp.ch_name as name, count(*) as c\n            from (select ch.name as ch_name, ch.country_code as ch_ct, m.winner_code as win from coaches as ch, medals as m where ch.discipline = m.discipline) as tmp, (select code, any_value(country_code) as ct from teams group by code) as t\n            where tmp.win = t.code and tmp.ch_ct = t.ct\n            group by tmp.ch_name\n            having c > 0\n        ) as q1\n    group by q1.name\n    order by s desc, q1.name;\n    ```\n\n2. 查询所有柔道选手的姓名和奖牌数，并按以奖牌数为第一关键字降序、以名字为第二关键字字典序排序\n\n    分析：\n\n    首先查询所有柔道选手\n\n    ```SQL\n    select name from athletes where disciplines = \"['Judo']\";\n    ```\n\n    还有一个很有意思的事情就是 `Duckdb` 不支持双引号，所以你需要这样写\n\n    ```SQL\n    select name from athletes where disciplines = '[''Judo'']';\n    ```\n\n    然后选出所有的柔道奖牌\n\n    ```SQL \n    select winner_code from medals where discipline = 'Judo';\n    ```\n\n    选手可能自己拿牌子，也可能通过队伍拿牌子，但是牌子数量是一定的\n\n    先算个人拿的牌子\n\n    ```SQL\n    select a.name, count(*)\n    from athletes as a, medals as m\n    where a.disciplines = \"['Judo']\" and m.discipline = 'Judo' and m.winner_code = a.code\n    group by a.name;\n    ```\n\n    再算在队伍中拿的牌子\n\n    ```SQL\n    select a.name as name, t.code as t_code\n    from athletes as a, teams as t\n    where a.disciplines = \"['Judo']\" and a.code = t.athletes_code;\n    ```\n\n    ```SQL\n    select p.name, count(*)\n    from (\n    \tselect a.name as name, t.code as t_code\n        from athletes as a, teams as t\n        where a.disciplines = \"['Judo']\" and a.code = t.athletes_code\n    ) as p, medals as m\n    where p.t_code = m.winner_code\n    group by p.name;\n    ```\n\n    再合并排序，注意最后要加上奖牌数为 $0$ 的选手\n\n    ```SQL\n    -- SQLite\n    select q2.name, sum(c) as s\n    from \n    \t(\n            select a.name as name, count(*) as c\n            from athletes as a, medals as m\n            where a.disciplines = \"['Judo']\" and m.discipline = 'Judo' and m.winner_code = a.code\n            group by a.name\n        union all\n        \tselect p.name as name, count(*) as c\n            from (\n                select a.name as name, t.code as t_code\n                from athletes as a, teams as t\n                where a.disciplines = \"['Judo']\" and a.code = t.athletes_code\n            ) as p, medals as m\n            where p.t_code = m.winner_code\n            group by p.name\n        union all\n            select name,0 from athletes where disciplines = \"['Judo']\"\n    \t) as q2\n    group by q2.name\n    order by s desc, q2.name;\n    ```\n\n    ```SQL\n    -- Duckdb\n    select q2.name, sum(c) as s\n    from \n    \t(\n            select a.name as name, count(*) as c\n            from athletes as a, medals as m\n            where a.disciplines = '[''Judo'']' and m.discipline = 'Judo' and m.winner_code = a.code\n            group by a.name\n        union all\n        \tselect p.name as name, count(*) as c\n            from (\n                select a.name as name, t.code as t_code\n                from athletes as a, teams as t\n                where a.disciplines = '[''Judo'']' and a.code = t.athletes_code\n            ) as p, medals as m\n            where p.t_code = m.winner_code\n            group by p.name\n        union all\n            select name,0 from athletes where disciplines = '[''Judo'']'\n    \t) as q2\n    group by q2.name\n    order by s desc, q2.name;\n    ```\n\n3. 对于所有举办过田径项目的地点，列出所有在该地点比过赛的运动员，并按以其国籍所在国与代表国之间的距离为第一关键字降序、以名字为第二关键字字典序排序\n\n    分析：\n\n    先查所有举办过田径项目的地点所对应的比赛结果\n\n    ```SQl\n    select r.participant_code from results as r, venues as v where v.disciplines like '%Athletics%' and r.venue = v.venue;\n    ```\n\n    再查人（还是分两部分，一部分个人，一部分队伍）\n\n    ```SQL\n    select a.name as ATHLETE_NAME, any_value(a.country_code) as REPRESENTED_COUNTRY_CODE, any_value(a.nationality_code) as NATIONALITY_COUNTRY_CODE\n    from\n    (\n        select r.participant_code as pc\n        from results as r, venues as v \n        where v.disciplines like '%Athletics%' and r.venue = v.venue\n    ) as rv, athletes as a\n    where rv.pc = a.code\n    group by a.name;\n    ```\n\n    ```SQL\n    select a.name as ATHLETE_NAME, any_value(a.country_code) as REPRESENTED_COUNTRY_CODE, any_value(a.nationality_code) as NATIONALITY_COUNTRY_CODE\n    from\n    (\n        select r.participant_code as pc\n        from results as r, venues as v \n        where v.disciplines like '%Athletics%' and r.venue = v.venue\n    ) as rv, teams as t, athletes as a\n    where rv.pc = t.code and t.athletes_code = a.code\n    group by a.name;\n    ```\n\n    再排序，有细节，注意只输出经纬度都不为空的数据，正确版本如下\n\n    ```SQL\n    -- Duckdb\n    with res as \n    (\n            select a.code, any_value(a.name) as ATHLETE_NAME, any_value(a.country_code) as REPRESENTED_COUNTRY_CODE, any_value(a.nationality_code) as NATIONALITY_COUNTRY_CODE\n            from\n            (\n                select r.participant_code as pc\n                from results as r, venues as v \n                where v.disciplines like '%Athletics%' and r.venue = v.venue\n            ) as rv, athletes as a\n            where rv.pc = a.code\n            group by a.code\n        union\n            select a.code, any_value(a.name) as ATHLETE_NAME, any_value(a.country_code) as REPRESENTED_COUNTRY_CODE, any_value(a.nationality_code) as NATIONALITY_COUNTRY_CODE\n            from\n            (\n                select r.participant_code as pc\n                from results as r, venues as v \n                where v.disciplines like '%Athletics%' and r.venue = v.venue\n            ) as rv, teams as t, athletes as a\n            where rv.pc = t.code and t.athletes_code = a.code\n            group by a.code\n    )\n    select res.ATHLETE_NAME, res.REPRESENTED_COUNTRY_CODE, res.NATIONALITY_COUNTRY_CODE\n    from res, countries as c1, countries as c2\n    where \n    (\n        res.REPRESENTED_COUNTRY_CODE = c1.code and \n        res.NATIONALITY_COUNTRY_CODE = c2.code and\n        c1.Latitude is not null and\n        c2.Latitude is not null and\n        c1.Longitude is not null and\n        c2.Longitude is not null\n    )\n    order by ((c1.Latitude-c2.Latitude)*(c1.Latitude-c2.Latitude)+(c1.Longitude-c2.Longitude)*(c1.Longitude-c2.Longitude)) desc, res.ATHLETE_NAME;\n    ```\n\n    在之前我犯了一个错误出现了如下的结果\n\n    Std:\n\n    <img src=\"https://p.ipic.vip/sxik4g.png\" alt=\"image-20250111075602898\" style=\"zoom:50%;\" />\n\n    My:\n\n    <img src=\"https://p.ipic.vip/vhae0x.png\" alt=\"image-20250111075649255\" style=\"zoom:50%;\" />\n\n    怎么活？\n\n    排查结果是，有一个重名的选手，也就是名字一样但编号不一样，`union` 的时候我没输出编号，只输出了名字，所以 `union` 语句自己给去重了，警钟长鸣\n\n    ```SQL\n    -- SQLite\n    with res as \n    (\n            select a.code, a.name as ATHLETE_NAME, a.country_code as REPRESENTED_COUNTRY_CODE, a.nationality_code as NATIONALITY_COUNTRY_CODE\n            from\n            (\n                select r.participant_code as pc\n                from results as r, venues as v \n                where v.disciplines like '%Athletics%' and r.venue = v.venue\n            ) as rv, athletes as a\n            where rv.pc = a.code\n            group by a.code\n        union\n            select a.code, a.name as ATHLETE_NAME, a.country_code as REPRESENTED_COUNTRY_CODE, a.nationality_code as NATIONALITY_COUNTRY_CODE\n            from\n            (\n                select r.participant_code as pc\n                from results as r, venues as v \n                where v.disciplines like '%Athletics%' and r.venue = v.venue\n            ) as rv, teams as t, athletes as a\n            where rv.pc = t.code and t.athletes_code = a.code\n            group by a.code\n    )\n    select res.ATHLETE_NAME, res.REPRESENTED_COUNTRY_CODE, res.NATIONALITY_COUNTRY_CODE\n    from res, countries as c1, countries as c2\n    where \n    (\n        res.REPRESENTED_COUNTRY_CODE = c1.code and \n        res.NATIONALITY_COUNTRY_CODE = c2.code and\n        c1.Latitude is not null and\n        c2.Latitude is not null and\n        c1.Longitude is not null and\n        c2.Longitude is not null\n    )\n    order by ((c1.Latitude-c2.Latitude)*(c1.Latitude-c2.Latitude)+(c1.Longitude-c2.Longitude)*(c1.Longitude-c2.Longitude)) desc, res.ATHLETE_NAME;\n    ```\n\n4. 对于每一天，找到当天在前五名（包括）中出现次数最多的国家，同时列出其人口排名和 GDP 排名，并按日期升序排序\n\n    分析：\n\n    先查每一天各个国家在前五名的记录，注意这里是 `union all` \n\n    ```SQL\n    \tselect r.date as date, a.country_code as country_code, r.rank\n        from results as r, athletes as a\n        where r.participant_code = a.code and r.rank <= 5 and r.rank is not null\n    union all\n    \tselect r.date as date, t.country_code as country_code, r.rank\n    \tfrom results as r, (select teams.code as code, any_value(teams.country_code) as country_code from teams group by teams.code) as t\n    \twhere r.participant_code = t.code and r.rank <= 5 and r.rank is not null;\n    ```\n\n    再通过横向查询算出每天各个国家在前五名中出现的次数\n\n    ```SQL\n    with tms as \n    (\n    \tselect r.date as date, a.country_code as country_code, r.rank\n        from results as r, athletes as a\n        where r.participant_code = a.code and r.rank <= 5 and r.rank is not null\n    \tunion all\n    \tselect r.date as date, t.country_code as country_code, r.rank\n    \tfrom results as r, (select teams.code as code, any_value(teams.country_code) as country_code from teams group by teams.code) as t\n    \twhere r.participant_code = t.code and r.rank <= 5 and r.rank is not null\n    )\n    select distinct t1.date, t1.country_code, times.c\n    from tms as t1, \n    \tlateral \n    \t(\n            select count(*) as c\n            from tms as t2\n            where t2.date = t1.date and t2.country_code = t1.country_code\n    \t) as times\n    order by t1.date asc;\n    ```\n\n    利用窗口函数得到每天次数最大的一个 tuple\n\n    ```SQL\n    with max_t as\n    (\n        select \n            *, \n            row_number() over (partition by mdt.date order by mdt.c desc, mdt.country_code) as rk\n        from\n        (\n            with tms as \n            (\n                select r.date as date, a.country_code as country_code, r.rank\n                from results as r, athletes as a\n                where r.participant_code = a.code and r.rank <= 5 and r.rank is not null\n                union all\n                select r.date as date, t.country_code as country_code, r.rank\n                from results as r, (select teams.code as code, any_value(teams.country_code) as country_code from teams group by teams.code) as t\n                where r.participant_code = t.code and r.rank <= 5 and r.rank is not null\n            )\n            select distinct t1.date as date, t1.country_code as country_code, times.c as c\n            from tms as t1, \n                lateral \n                (\n                    select count(*) as c\n                    from tms as t2\n                    where t2.date = t1.date and t2.country_code = t1.country_code\n                ) as times\n        ) as mdt\n    )\n    select m.date, m.country_code, m.c\n    from max_t as m\n    where rk = 1\n    order by m.date asc;\n    ```\n\n    查询 GDP_rank 和 populartion_rank \n\n    ```SQL\n    select \n    \tcode,  \n    \trank() over (order by Population desc) as rk_pop, \n    \trank() over (order by \"GDP ($ per capita)\" desc) as rk_GDP\n    from countries\n    where \n    \t\"GDP ($ per capita)\" is not null and\n    \tPopulation is not null;\n    ```\n\n    合并！排序！\n\n    ```SQL\n    -- Duckdb\n    with max_t as\n    (\n        select \n            *, \n            row_number() over (partition by mdt.date order by mdt.c desc, mdt.country_code) as rk\n        from\n        (\n            with tms as \n            (\n                select r.date as date, a.country_code as country_code, r.rank\n                from results as r, athletes as a\n                where r.participant_code = a.code and r.rank <= 5 and r.rank is not null\n                union all\n                select r.date as date, t.country_code as country_code, r.rank\n                from results as r, (select teams.code as code, any_value(teams.country_code) as country_code from teams group by teams.code) as t\n                where r.participant_code = t.code and r.rank <= 5 and r.rank is not null\n            )\n            select distinct t1.date as date, t1.country_code as country_code, times.c as c\n            from tms as t1, \n                lateral \n                (\n                    select count(*) as c\n                    from tms as t2\n                    where t2.date = t1.date and t2.country_code = t1.country_code\n                ) as times\n        ) as mdt\n    )\n    select m.date as date, m.country_code as country_code, m.c as top5_appearances, ct_info.rk_GDP as gdp_rank, ct_info.rk_pop as population_rank\n    from \n    \tmax_t as m, \n    \t(\n        \tselect \n                code,  \n                rank() over (order by Population desc) as rk_pop, \n                rank() over (order by \"GDP ($ per capita)\" desc) as rk_GDP\n            from countries\n            where \n                \"GDP ($ per capita)\" is not null and\n                Population is not null\n        ) as ct_info\n    where rk = 1 and ct_info.code = m.country_code\n    order by m.date asc;\n    ```\n\n    `SQLite` 不支持横向查询 `lateral` 关键字\n\n    ```SQL\n    -- SQLite\n    with max_t as\n    (\n        select \n            *, \n            row_number() over (partition by mdt.date order by mdt.c desc, mdt.country_code) as rk\n        from\n        (\n            with tms as \n            (\n                select r.date as date, a.country_code as country_code, r.rank\n                from results as r, athletes as a\n                where r.participant_code = a.code and r.rank <= 5 and r.rank is not null\n                union all\n                select r.date as date, t.country_code as country_code, r.rank\n                from results as r, (select teams.code as code, teams.country_code as country_code from teams group by teams.code) as t\n                where r.participant_code = t.code and r.rank <= 5 and r.rank is not null\n            )\n            select distinct t1.date as date, t1.country_code as country_code, times.c as c\n            from tms as t1\n            left join\n           \t(\n            \tselect t2.date, t2.country_code, count(*) as c\n                from tms as t2\n                group by t2.date, t2.country_code\n            ) as times\n            on t1.date = times.date and t1.country_code = times.country_code\n        ) as mdt\n    )\n    select m.date as date, m.country_code as country_code, m.c as top5_appearances, ct_info.rk_GDP as gdp_rank, ct_info.rk_pop as population_rank\n    from \n    \tmax_t as m, \n    \t(\n        \tselect \n                code,  \n                rank() over (order by Population desc) as rk_pop, \n                rank() over (order by \"GDP ($ per capita)\" desc) as rk_GDP\n            from countries\n            where \n                \"GDP ($ per capita)\" is not null and\n                Population is not null\n        ) as ct_info\n    where rk = 1 and ct_info.code = m.country_code\n    order by m.date asc;\n    ```\n\n5. 对比于东京奥运会，列出在金牌数量上有最大进步的五个国家，对于这五个国家，列出所属所有全女生的队伍，并按以提升的金牌数为第一关键字降序、以国家 code 为第二关键字字典序、以队伍 code 为第三关键字字典序排序\n\n    分析：\n\n    先查出所有国家的金牌数量\n\n    ```SQL\n    select s1.cc, sum(s)\n    from\n    (\n        select c.code as cc, count(*) as s\n        from medals as m, countries as c, athletes as a, medal_info as mi\n        where \n        \tm.winner_code = a.code and \n        \ta.country_code = c.code and \n        \tmi.code = m.medal_code and \n        \tmi.name = 'Gold Medal'\n        group by c.code\n        union all\n        select c.code as cc, count(*) as s\n        from medals as m, countries as c, (select code, any_value(country_code) as country_code from teams group by code) as t, medal_info as mi\n        where \n    \tm.winner_code = t.code and \n        \tt.country_code = c.code and\n    \tmi.code = m.medal_code and\n        \tmi.name = 'Gold Medal'\n        group by c.code\n    ) as s1\n    group by cc;\n    ```\n    \n    再查出所有国家进步的金牌数量，以及前五\n    \n    ```SQL\n    select \n    \ts1.cc, \n    \t(sum(s)-any_value(tm.gold_medal)) as increased_gold_medal_number, \n    \trank() over (order by increased_gold_medal_number desc) as rk\n    from\n    (\n        select c.code as cc, count(*) as s\n        from medals as m, countries as c, athletes as a, medal_info as mi\n    where \n        \tm.winner_code = a.code and \n        \ta.country_code = c.code and \n        \tmi.code = m.medal_code and \n        \tmi.name = 'Gold Medal'\n        group by c.code\n        union all\n        select c.code as cc, count(*) as s\n        from medals as m, countries as c, (select code, any_value(country_code) as country_code from teams group by code) as t, medal_info as mi\n        where \n        \tm.winner_code = t.code and \n        \tt.country_code = c.code and\n        \tmi.code = m.medal_code and\n        \tmi.name = 'Gold Medal'\n        group by c.code\n    ) as s1 left join tokyo_medals as tm\n    on s1.cc = tm.country_code\n    where tm.gold_medal is not null\n    group by cc\n    order by rk\n    limit 5;\n    ```\n    \n    找全女队\n    \n    ```SQL\n    with sm1 as\n    (\n        select t.code as code, count(*) as c, any_value(t.country_code) as cc\n        from teams as t, athletes as a\n        where t.athletes_code = a.code\n        group by t.code\n    ),\n    sm2 as\n    (\n        select t.code as code, count(*) as c, any_value(t.country_code) as cc\n        from teams as t, athletes as a, gender as g\n        where \n            t.athletes_code = a.code and \n            a.gender = g.id and \n            g.name = 'Female'\n        group by t.code\n    )\n    select sm1.cc, sm1.code\n    from sm1, sm2\n    where sm1.code = sm2.code and sm1.c = sm2.c;\n    ```\n    \n    合并！排序！\n    \n    ```SQL\n    -- Duckdb\n    with tmp as\n    (\n        select \n            s1.cc, \n            (sum(s)-any_value(tm.gold_medal)) as increased_gold_medal_number, \n            rank() over (order by increased_gold_medal_number desc) as rk\n        from\n        (\n            select c.code as cc, count(*) as s\n            from medals as m, countries as c, athletes as a, medal_info as mi\n            where \n                m.winner_code = a.code and \n                a.country_code = c.code and \n                mi.code = m.medal_code and \n                mi.name = 'Gold Medal'\n            group by c.code\n            union all\n            select c.code as cc, count(*) as s\n            from medals as m, countries as c, (select code, any_value(country_code) as country_code from teams group by code) as t, medal_info as mi\n            where \n                m.winner_code = t.code and \n                t.country_code = c.code and\n                mi.code = m.medal_code and\n                mi.name = 'Gold Medal'\n            group by c.code\n        ) as s1 left join tokyo_medals as tm\n        on s1.cc = tm.country_code\n        where tm.gold_medal is not null\n        group by cc\n        order by rk\n        limit 5\n    ),\n    sm1 as\n    (\n        select t.code as code, count(*) as c, any_value(t.country_code) as cc\n        from teams as t, athletes as a\n        where t.athletes_code = a.code\n        group by t.code\n    ),\n    sm2 as\n    (\n        select t.code as code, count(*) as c, any_value(t.country_code) as cc\n        from teams as t, athletes as a, gender as g\n        where \n            t.athletes_code = a.code and \n            a.gender = g.id and \n            g.name = 'Female'\n        group by t.code\n    )\n    select tmp.cc as country_code, tmp.increased_gold_medal_number as increased_gold_medal_number, sm1.code as team_code\n    from sm1, sm2, tmp\n    where tmp.cc = sm1.cc and sm1.code = sm2.code and sm1.c = sm2.c\n    order by increased_gold_medal_number desc, country_code, team_code;\n    ```\n    \n    ```SQL\n    -- SQLite\n    with tmp as\n    (\n        select \n            s1.cc, \n            (sum(s)-tm.gold_medal) as increased_gold_medal_number, \n            rank() over (order by (sum(s)-tm.gold_medal) desc) as rk\n        from\n        (\n            select c.code as cc, count(*) as s\n            from medals as m, countries as c, athletes as a, medal_info as mi\n            where \n                m.winner_code = a.code and \n                a.country_code = c.code and \n                mi.code = m.medal_code and \n                mi.name = 'Gold Medal'\n            group by c.code\n            union all\n            select c.code as cc, count(*) as s\n            from medals as m, countries as c, (select code, country_code as country_code from teams group by code) as t, medal_info as mi\n            where \n                m.winner_code = t.code and \n                t.country_code = c.code and\n                mi.code = m.medal_code and\n                mi.name = 'Gold Medal'\n            group by c.code\n        ) as s1 left join tokyo_medals as tm\n        on s1.cc = tm.country_code\n        where tm.gold_medal is not null\n        group by cc\n        order by rk\n        limit 5\n    ),\n    sm1 as\n    (\n        select t.code as code, count(*) as c, t.country_code as cc\n        from teams as t, athletes as a\n        where t.athletes_code = a.code\n        group by t.code\n    ),\n    sm2 as\n    (\n        select t.code as code, count(*) as c, t.country_code as cc\n        from teams as t, athletes as a, gender as g\n        where \n            t.athletes_code = a.code and \n            a.gender = g.id and \n            g.name = 'Female'\n        group by t.code\n    )\n    select tmp.cc as country_code, tmp.increased_gold_medal_number as increased_gold_medal_number, sm1.code as team_code\n    from sm1, sm2, tmp\n    where tmp.cc = sm1.cc and sm1.code = sm2.code and sm1.c = sm2.c\n    order by increased_gold_medal_number desc, country_code, team_code;\n    ```\n","tags":["CMU","Databases"],"categories":["公开课"]},{"title":"CMU15445项目笔记","url":"/2024/12/09/CMU15445-learning-note-pro/","content":"\n学一学CMU的15445，[课程地址](https://15445.courses.cs.cmu.edu/fall2024/) \n\n<!--more-->\n\n## Project #0 - C++ Primer\n\n### C++ Bootcamp\n\n主要针对 C++17 特性，共 $19$ 个文件。\n\n1. references.cpp\n\n    有关引用（别名），函数传引用\n\n2. move_semantics.cpp\n\n    有关移动语义和右值引用\n\n    - lvalue（左值）：refer to 内存中某个有权限访问的区域的对象\n\n        rvalue（右值）：非左值的值，数据位于的区域没有权限访问（字面常量）或者没有必要访问（匿名对象），包括**将亡值**和**纯右值** \n\n        赋值语句中等号左边的必须是左值，右边的随便\n\n    - 左值引用（&）和右值引用（&&）都必须立即初始化，右值引用可以**通过移动的方式在浅拷贝的情况下保证拷贝的安全性**，在设计和实现类时，对于需要动态申请大量资源的类，应该设计右值引用的拷贝构造函数和赋值函数，以提高应用程序的效率，具体 3. 中有讲\n    - std::move() 方法可以将左值转换为右值，即将亡值，方便使用移动语义，需要 ``<utility>`` 头文件\n\n3. move_constructors.cpp\n\n    有关应用移动语义的拷贝构造函数和赋值重载函数\n\n    在类定义中删除左值引用的拷贝构造函数和赋值重载函数，意味着实例化后就不再允许被复制，防止双重删除或者内存泄露\n\n    References：\n\n    - [C++11右值引用|移动语义|完美转发|巨巨巨详细](https://zhuanlan.zhihu.com/p/677643121)\n    - [C++|左值、右值、将亡值|谈谈我对它们的深入理解](https://zhuanlan.zhihu.com/p/620583555)\n\n4. templated_functions.cpp\n\n    有关模板函数\n\n    注意模板参数不一定要是 ``class`` 或者 ``typename``，也可以是别的，但没必要\n\n5. templated_classes.cpp\n\n    有关模板类\n\n6. wrapper_class.cpp\n\n    有关包装类\n\n    - RAII（Resource Acquisition is Initialization）：一个实例化管理一个资源，防止双重删除或内存泄露\n    - 使用移动语义\n\n7. iterator.cpp\n\n    有关迭代器，实现了一个双向链表（DLL）及其迭代器\n\n8. namespaces.cpp\n\n    有关命名空间\n\n9. vectors.cpp\n\n    有关动态数组\n\n    ``std::remove_if()`` 不能删除元素，只能将元素移到末尾，配合 ``erase()`` 函数才能删掉\n\n    ``emplace_back()`` 比 ``push_back()`` 稍快\n\n10. sets.cpp\n\n    有关集合\n\n    ``count()`` 函数\n\n11. unordered_maps.cpp\n\n    有关映射\n\n    ``count()`` 函数\n\n12. auto.cpp\n\n    有关 ``auto`` 类型使用\n\n13. unique_ptr.cpp\n\n    有关智能指针类型 ``unique_ptr`` 使用\n\n    - 需要 ``<memory>`` 头文件\n\n    - ``unique_ptr`` 保留对象的唯一所有权，没有两个 ``unique_ptr`` 指针指向同一个对象\n\n    - 初始化\n\n        ```C++\n        //利用make_unique<>()方法初始化，调用的构造函数是<>类型的构造函数\n        std::unique_ptr<Point> u = std::make_unique<Point>();\n        ```\n\n    - 可以通过移动语义转移所有权\n\n14. shared_ptr.cpp\n\n    有关智能指针类型 ``shared_ptr`` 使用\n\n    - 需要 ``<memory>`` 头文件\n\n    - 可以有多个 ``shared_ptr`` 指针指向同一个对象\n\n    - 初始化\n\n        ```c++\n        //利用make_shared<>()方法初始化，调用的构造函数是<>类型的构造函数\n        std::shared_ptr<Point> u = std::make_shared<Point>();\n        ```\n\n    - 通过 ``use_count()`` 方法可以得到有多少个指针指向同个对象\n\n    - 可以通过移动语义转移所有权\n\n15. mutex.cpp\n\n    有关互斥锁\n\n    - 同步原语（Synchronization Primitives）是用于支持此多线程环境下线程同步的工具和机制。这些源于主要用于管理线程之间对共享资源的访问，防止数据竞争和保证线程安全\n    - ``std::mutex`` 提供独占锁，确保同一时间只有一个线程可以获得互斥量，不可复制，不可移动\n    - 互斥量状态：\n        - 解锁状态意味着共享资源可用\n        - 加锁状态意味着共享资源不可用\n    - 需要 ``<mutex>`` 和 ``<thread>`` 头文件\n    - ``lock()`` 锁住互斥量，``unlock()`` 解锁互斥量，``try_lock()`` 尝试锁住互斥量\n    - 被阻塞\n\n    References：\n\n    - [C++多线程——互斥量mutex](https://blog.csdn.net/qq_74811378/article/details/144144933) \n\n16. scoped_lock.cpp\n\n    有关多个互斥量的管理\n\n    - 需要 ``<mutex>`` 和 ``<thread>`` 头文件\n\n    - 当创建一个 `std::scoped_lock` 对象时，它尝试取得其所给互斥量的所有权。当控制权离开创建 `scoped_lock` 对象的作用域时，`scoped_lock` 会被析构，互斥量随之被释放。如果给定了多个互斥量，将使用避免死锁的算法，类似于 `std::lock` \n\n    - 是一个 RAII 风格的类\n\n    - ``scoped_lock`` 类不可复制，不可移动\n\n    References：\n\n    - [【C++ 17 新特性 互斥锁】std::scoped_lock 的使用，管理多个互斥量](https://blog.csdn.net/qq_21438461/article/details/135670987) \n\n17. condition_variable.cpp\n\n    有关条件变量\n\n    - 需要 `<condition_variable>` 头文件\n    - 功能：\n        - 拥有条件变量的线程获取互斥量\n        - 循环检查某个条件，如果条件不满足则阻塞直到满足；如果满足则向下执行\n        - 某个线程满足条件执行完之后调用 `notify_one` 或 `notify_all` 唤醒一个或所有等待线程\n    - `wait()` 第一个参数必须用 `unique_lock` \n    - `unique_lock` 不能复制，可以移动\n\n    References：\n\n    - [C++11条件变量condition_variable详解](https://zhuanlan.zhihu.com/p/599172163) \n    - [【C++】独占互斥锁（unique_lock）](https://blog.csdn.net/u013043408/article/details/138437356) \n\n18. rwlock.cpp\n\n    有关读写器锁的用法\n\n    - 用 `std::shared_mutex`、`std::shared_lock` 和 `std::unique_lock` \n    - 需要 `<shared_mutex>` \n    - `std::mutex` 和 `std::shared_mutex` 的区别：\n        - `std::mutex` 提供独占访问，同一时间只能有一个线程持有该类型的锁\n        - `std::shared_mutex` 提供共享访问和独占访问，允许多个线程通过持有 `std::shared_lock` 共享锁来只读访问，允许一个线程持有 `std::unique_lock` 独占锁来进行写操作，但是共享锁和独占锁不能同时存在，互斥\n        - `std::shared_mutex` 更适用于读多写少的场景\n\n19. s24_my_ptr.cpp\n\n    实现了一个 `std::unique_pointer<T>` 类\n\n    - 使用原始指针类型，很可能会出现内存泄露，二次释放，释放后访问的问题\n    - RAII 的好处\n    - `smart_generator<int>()` 和 `dumb_generator<int>()` 的区别\n\n### HyperLogLog 算法\n\nHyperLogLog 算法是一种用于估计大规模数据集基数的随机化算法\n\n基数（cardinality）：集合中不同元素的个数\n\n时间复杂度：\n\n-  $O(1)$ 插入\n-  $O(1)$ 查询\n-  $O(1)$ 合并两个计数器\n\n基本原理：\n\n基于抛硬币的原理，由连续抛硬币出现正面的概率来估算一共抛硬币的次数\n\n相似的，我们可以将主键进行哈希，得到一个 01 串，通过统计从第零位开始连续的 $0$ 的个数的最大值来估算基数\n\n为了减小偶然性，可以设置 $m$ 个寄存器，分别统计连续 $0$ 的个数的最大值，取01串的前 $k$ 高位作为寄存器编号，分别在各自寄存器内更新，最后综合起来计算答案即可\n\nPresto 的实现其实就是为了减小寄存器（dense_bucket_）的大小，将超出寄存器表示范围的部分存到另一个 unordered_map（overflow_bucket\\_）中，因为有时某些寄存器根本没有用到，无用空间过多\n\n代码并不难写，主要是弄懂怎么调试……使用 `bustub` 已经配置好的 `google test` 调试各个函数就好\n\n<img src=\"https://p.ipic.vip/9v9etd.png\" alt=\"image-20250110153509098\" style=\"zoom:70%;\" />\n\n上图是我瞎写了一通以后拿的分数，看了看 results 发现答案没问题，但是存在内存泄露，因为我寄存器是用动态分配空间的数组实现的，这就需要在类析构的时候 `free()` 掉，写了一个析构函数就过了，如果使用 STL​ 中的 `vector` 就不会出现内存泄露，因为 C++ 的 STL 都遵循 RAII 的原则\n\n<img src=\"https://p.ipic.vip/asq6ia.png\" alt=\"image-20250110162252511\" style=\"zoom:70%;\" />\n\n还有一个比较蛋疼的地方就是格式问题，格式不对就给判成 $0$ 分，需要注意一下\n\n---\n\n## Project #1 - Buffer Pool Manager\n\n### Task #1 - LRU-K Replacement Policy\n\n要求实现一个 LRU 替换算法，具体实现就是整了一个容器叫 LRU-K Replacer，然后对其中的 frames 进行计算和操作\n\n","tags":["CMU","Databases"],"categories":["公开课"]},{"title":"CMU15445听课笔记","url":"/2024/12/09/CMU15445-learning-note/","content":"\n学一学CMU的15445，[课程地址](https://15445.courses.cs.cmu.edu/fall2024/) \n\n<!--more-->\n\n## Lecture #01 - Relational Model & Algebra\n\n[Notes](https://15445.courses.cs.cmu.edu/fall2024/notes/01-relationalmodel.pdf) \n\n一些有关关系型数据库的概念，一些关系源语\n\n---\n\n## Lecture #02 - Modern SQL\n\n[Notes](https://15445.courses.cs.cmu.edu/fall2024/notes/02-modernsql.pdf) \n\n彩蛋：Andy 教授在课上播放了在若干年前他教他的女儿写第一条 SQL 查询语句的视频，太可爱了\n\n<img src=\"https://p.ipic.vip/bsbxw9.png\" alt=\"image-20250110223425109\" style=\"zoom:50%;\" />\n\n不同 DBMS 所使用的 SQL 语法有所不同，但最后都要有分号！！！\n\n补充一些之前没有学习到并且很重要的 SQL 语句\n\n- 窗口函数（Window Function）是 SQL 中一种可以在查询结果中对一组行进行计算的函数。与聚合函数（如 SUM、AVG、COUNT 等）不同，聚合函数会对一组行返回一个单一的值，而窗口函数可以对每一行单独进行计算，并且仍然保留查询结果中的所有行（MySQL 不支持）\n\n    ```SQL\n    SELECT 列1, 列2, \n           窗口函数() OVER (\n               PARTITION BY 列名 \n               ORDER BY 列名 \n               ROWS/RANGE BETWEEN \n               UNBOUNDED PRECEDING AND CURRENT ROW\n           )\n    FROM 表名;\n    ```\n\n    1. 窗口函数：指你使用的函数（如 `ROW_NUMBER()`、`RANK()`、`SUM()`、`AVG()`、`LEAD()`、`LAG()` 等）\n  2. `OVER()` 子句：定义了窗口，也就是窗口函数操作的行集\n         - `PARTITION BY`：用来将结果集分成不同的分区，每个分区会单独计算窗口函数。类似于 `GROUP BY` \n         - `ORDER BY`：定义了每个分区中行的排序，通常是需要的，特别是对于 `ROW_NUMBER()`、`RANK()` 这样的函数\n         - `ROWS/RANGE`：定义了窗口框架，决定哪些行会被包含在每次计算中\n  \n- 横向查询（Lateral Join）是 SQL 中的一种连接类型，它允许子查询引用来自外部查询的列。具体来说，LATERAL 关键字使得子查询在每一行外部查询的结果集时可以“横向”展开，从而为每一行产生不同的结果\n\n    简单来说，LATERAL 使得子查询在查询执行过程中能够访问外部查询的每一行数据，而不像普通的子查询那样仅仅返回一个固定结果\n\n- Common Table Expressions (CTEs) 是 SQL 中的一种构造方式，它允许你定义一个临时结果集（类似于视图），并在查询的其他部分引用它。CTE 提高了查询的可读性和可维护性，特别是在处理复杂的查询时。CTE 是通过使用 WITH 关键字来定义的，它通常用于临时计算、递归查询或者分步解决复杂查询的问题\n\n    ```SQL\n    WITH cte_name AS (\n        -- 子查询\n        SELECT column1, column2\n        FROM table\n        WHERE condition\n    )\n    SELECT * FROM cte_name;\n    ```\n\n---\n\n## Lecture #03 - Database Storage I\n\n[Notes](https://15445.courses.cs.cmu.edu/fall2024/notes/03-storage1.pdf) \n\nAndy 教授说话太快了 T_T\n\nfocus on Disk-oriented DBMS\n\n<img src=\"https://p.ipic.vip/2z04uj.png\" alt=\"image-20250111144703544\" style=\"zoom:80%;\" />\n\n这个机制很像 OS 中的 Virtual Memory 的实现，Buffer Pool 类似 TLB \n\n本节主要讨论 DBMS 如何在磁盘文件中组织数据\n\n1. The DBMS stores a databases as one or more files on disk typically in a proprietary format\n\n2. the storage manager 负责将数据以页面的形式组织在文件中，同时追踪数据读写和可用空间，通常不建立和维护页面副本\n\n3. 数据（tuples, meta-data, indexes, log records...）在文件中以 pages 的形式被存储\n\n    - 有些 DBMS 要求页面 self-contained (e.g., Oracle)，原因是在 disaster recovery 时可以恢复尽可能多的数据\n\n    - 每个页有唯一的 page ID 便于检索，the DBMS uses an indirection layer to map page IDs to physical locations\n\n    - 三种 page：Hardware Page (usually 4KB), OS Page (usually 4KB, x64 2MB/1GB), Database Page (512B-32KB)\n\n    - A hardware page is the largest block of data that the storage device can guarantee failsafe writes\n\n4. 大部分 DBMSs 以 Heap File Organization 的方式组织文件中的 pages\n\n    - A heap file is an unordered collection of pages with tuples that are stored in random order.\n\n        <img src=\"https://p.ipic.vip/5fblb5.png\" alt=\"image-20250112021218141\" style=\"zoom:80%;\" />\n\n5. Every page contains a header of meta-data about the page's contents (e.g., page size, checksum, DBMS version, transaction visibility, compression/encoding meta-data, schema information, data summary/sketches)\n\n6. 页面中组织数据三种方式：Tuple-oriented Storage, Log-structured Storage, Index-organized Storage\n\n7. Tuple-oriented Storage 的一种普遍的实现方式：slotted pages\n\n    <img src=\"https://p.ipic.vip/qm12mh.png\" alt=\"image-20250112030826236\" style=\"zoom:80%;\" />\n\n    - 插入一个新元组：\n        - 检查 page directory 找到一个有 free slot 的 page\n        - 如果不在内存中的话从磁盘中检索该 page\n        - 检查 slot array 找到可以盛下的空位\n    - 利用 Record ID 更新已有的元组:\n        - 检查 page directory 找到 page 位置\n        - 如果不在内存中的话从磁盘中检索该 page\n        - 检查 slot array 找到偏移量\n        - 如果新数据可以盛下就覆盖原有数据，否则把原有数据标记删除，在新页面插入一个新版本\n\n8. Record IDs: The DBMS assigns each logical tuple a unique record identifier that that represents its physical location in the database (but shouldn't be relied on to fetch data)\n\n最后 tuple layout 的部分 Andy 教授没有讲完，有一些疑惑问了 ChatGPT，记录一下\n\n9. A tuple is essentially a sequence of bytes. **These bytes do not have to be contiguous.** 这个下一节的 `large value` 会提到\n10. tuple 存储的时候也有自己的 header，主要存储 Visibility info（事务信息，支持并发控制）和 Null Bitmap（空值位图），不存储每个 attribute 的类型，这个下一节的 `system catalogs` 会提到\n11. Denormalize: If two tables are related, the DBMS can \"pre-join\" them, so the tables end up on the same page. This makes reads faster since the DBMS only has to load in one page rather than two separate pages. However, it makes updates more expensive since the DBMS needs more space for each tuple\n\n---\n\n## Lecture #04 - Database Storage II\n\n[Notes](https://15445.courses.cs.cmu.edu/fall2024/notes/04-storage2.pdf) \n\n### Log-Structured Storage\n\n查询/修改过程：\n\n<img src=\"https://p.ipic.vip/fsm2r4.png\" alt=\"image-20250112062356080\" style=\"zoom:80%;\" />\n\n<img src=\"https://p.ipic.vip/v4hnac.png\" alt=\"image-20250112062425849\" style=\"zoom:80%;\" />\n\nSummaryTable 会告诉你你要找的数据在不在某一个 level\n\n<img src=\"https://p.ipic.vip/eq4xv1.png\" alt=\"image-20250112064529446\" style=\"zoom:80%;\" />\n\nSSTables 的压缩过程：\n\n<img src=\"https://p.ipic.vip/25wsoa.png\" alt=\"image-20250112065519014\" style=\"zoom:80%;\" />\n\n缺点：\n\n- 写放大（Write-Amplification）：在一个写操作后，这个操作会被重写若干次\n- 压缩成本高（Compaction is expensive）\n\nIdeal for write-heavy workloads because it maximizes sequential disk I/O\n\n### Index-Organized Storage\n\nB+树为例\n\n<img src=\"https://p.ipic.vip/n9yx03.png\" alt=\"image-20250112070825294\" style=\"zoom:80%;\" />\n\n### Tuple Storage\n\n1. Data 只是一些 bytes，类型甚至是 unsigned char\\*，我们需要 `reinterpret_cast<int32_t*>(address)` （在C++中）\n2. 为了使查询快速，我们要保证 tuple 的属性值是字节对齐的\n3. 不一样的属性顺序排序可能会影响存储 tuple 的大小\n\n### Data Representation\n\n1. 单/双精度会有 rounding error，如果不能接受，使用 fixed precision numbers，如 numeric 和 decimal\n\n2. NULL Data Types\n\n    - Row-stores: Null Column Bitmap Header\n    - Column-stores: Special Valuew\n    - Per Attribute Null Flag，会打乱对齐，不建议\n\n3. 处理 large values\n\n    如果一个值需要的存储空间大于一个页了，DBMS 会将其存储在 overflow storage pages\n\n    <img src=\"https://p.ipic.vip/1ehuqg.png\" alt=\"image-20250113230311835\" style=\"zoom:80%;\" />\n\n    一些系统允许把 large value 存在外部文件里，类型为 BLOB，但是 DBMS 就管不了了\n\n---\n\n## \n","tags":["CMU","Databases"],"categories":["公开课"]},{"title":"MySQL 学习笔记进阶篇","url":"/2024/12/04/Mysql-learning-2/","content":"\n数据库进阶学习\n\n<!--more-->\n\n## 一、存储引擎\n\n### 1. MySQL 体系结构\n\n- 连接层\n- 服务层\n- 引擎层\n- 存储层\n\n### 2. 存储引擎\n\n存储数据、建立索引、更新/查询数据\n\n是基于表的，不是基于库的\n\n也称为表类型\n\n默认存储引擎：$INNODB$ \n\n查询当前数据库支持的存储引擎：``SHOW ENGINES;`` \n\n在创建表时，制定存储引擎：``CREATE TABLE 表名(……) ENGINE = 存储引擎名 [COMMENT 表注释];`` \n\n### 3. InnoDB\n\n高可靠性 高性能\n\n特点：\n\n- DML操作遵循ACID模型，支持事务\n- 行级锁，提高并发访问性能\n- 支持外键 ``FORRIGN KEY`` 约束，保证数据的完整性和正确性\n\n文件：``xxx.idb`` 称为表空间文件，存储表结构信息、数据和索引，二进制文件，cmd中使用 ``idb2sdi`` 命令查看\n\n​\t参数 ``innodb_file_per_table`` 表示每张表对应一个表空间文件\n\n逻辑存储结构：\n\n- 表空间：TableSpace\n- 段：Segment\n- 区：Extent（1M）\n- 页：Page（16K）\n- 行：Row\n\n### 4. MyISAM\n\n早期默认存储引擎\n\n特点：\n\n- 不支持事务，不支持外键\n- 支持表锁，不支持行锁\n- 访问速度快\n\n文件：\n\n- ``xxx.sdi`` 存储表结构信息\n- ``xxx.MYD`` 存储数据\n- ``xxx.MYI`` 存储索引\n\n### 5. Memory\n\n存储在内存中的，受到硬件问题，或断电问题影响，只能将这些表作为临时表或缓存使用\n\n特点：\n\n- 内存存放\n- hash索引（默认）\n\n文件：``xxx.sdi`` 存储表结构信息\n\n<img src=\"https://p.ipic.vip/8irxon.png\" alt=\"image-20241128110053093\" style=\"zoom:50%;\" />\n\n### 6. 存储引擎选择\n\n``InnoDB``：对事务的完整性有比较高的要求，在并发条件下要求数据的一致性。数据操作有插入查询还有更新删除\n\n``MyISAM``：数据操作主要是插入查询，很少更新删除，对事务完整性、并发性要求不高\n\n``Memory``：访问速度快，用于临时表及缓存\n\n## 二、索引\n\n帮助 $MySQL$ 高效获取数据的数据结构（有序）\n\n优点：提高数据检索的效率，降低数据库的IO成本；通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗\n\n缺点：索引列也要占用空间；降低更新表的速度\n\n### 1. 索引结构\n\n<img src=\"https://p.ipic.vip/yjws0n.png\" alt=\"image-20241128112807503\" style=\"zoom:100%;\" />\n\n一般是B+树索引\n\n#### B-Tree\n\n多路平衡查找树\n\n若最大度数为 $5$，每个节点最多存 $4$ 个 $key$，$5$ 个指针\n\n#### B+Tree\n\n对比 $B-Tree$ \n\n所有数据出现在叶子结点\n\n叶子结点形成一个单向链表\n\n优势：相对于二叉树，层级更少，搜索效率高；对于 $B-Tree$，叶子结点和非叶子结点都会保存数据，导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；对于 $Hash$ 索引，支持范围匹配和排序\n\n#### hash\n\n求 $hash$ 函数值，按值插入槽位\n\n不支持范围查询\n\n### 2. 索引分类\n\n<img src=\"https://p.ipic.vip/9npt7k.png\" alt=\"image-20241128115628405\" style=\"zoom:100%;\" />\n\n在 ``InnoDB`` 中，根据索引的存储形式，又分为以下两种：\n\n- 聚集索引(Clustered Index)：将数据存储与索引放到了一块，索引结构的叶子结点保存了行数据，必须有而且只能有一个\n- 二级索引(Secondary Index)：将数据与索引分开存储，索引结构的叶子结点关联的是对应的主键，可以有多个\n\n聚集索引选取规则：\n\n- 如果存在主键，主键索引就是聚集索引\n- 如果不存在主键，将使用第一个唯一索引作为聚集索引\n- 如果表没有主键，或没有合适的唯一索引，则 ``InnoDB`` 会自动生成一个 ``rowid`` 作为隐藏的聚集索引\n\n### 3. 索引语法\n\n- 创建索引：``CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name,...);`` \n- 查看索引：``SHOW INDEX FROM table_name;`` \n- 删除索引：``DROP INDEX index_name ON table_name;`` \n\n### 4. SQL性能分析\n\n#### SQL执行频率\n\n$MySQL$ 客户端连接成功后，通过 ``SHOW [SESSION|GLOBAL] STATUS`` 命令可以提供服务器状态信息。\n\n查看当前数据库的 ``INSERT``、``UPDATE``、``DELETE``、``SELECT`` 的访问频次：``SHOW GLOBAL STATUS LIKE 'Com_______'`` \n\n#### 慢查询日志\n\n慢查询日志记录了所有执行时间超过指定参数（$long\\_query\\_time$ ，单位：秒，默认 $10$ 秒）的所有SQL语句的日志。\n\n查看慢查询日志是否开启：``SHOW VARIABLES LIKE 'slow_query_log';`` \n\nMySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：\n\n```\n# 开启MySQL慢查询日志开关\nslow_query_log=1\n# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志\nlong_query_time=2\n```\n\n#### profile详情\n\nprofile能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过 ``have_profiling`` 参数，能够看到当前MySQL是否支持profile操作：``SELECT @@have_profiling;`` \n\n默认profiling是关闭的，可以通过set语句在session/global级别开启profiling：``SET profiling = 1;`` \n\n执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：\n\n```sql\n# 查看每一条SQL的耗时基本情况\nshow profiles;\n\n# 查看指定query_id的SQL语句各个阶段的耗时情况\nshow profile for query query_id;\n\n# 查看指定query_id的SQL语句CPU的使用情况\nshow profile cpu for query query_id;\n```\n\n #### explain执行计划\n\nexplain或desc命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接盒连接的顺序。\n\n```SQL\n# 直接在SELECT语句之前加上关键字EXPLAIN/DESC\nEXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;\n```\n\n字段含义：\n\n- id：select查询的序列号，表示查询中执行select字句或者是操作表的顺序（id相同，执行顺序从上到下；id不同，值越大，越先执行）。\n- select_type：表示select的类型，常见的取值有SIMPLE（简单表，即不使用表连接或子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等。\n- type：表示链接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all。\n- possible_key：显示可能应用在这张表上的索引，一个或多个。\n- key：实际使用的索引，如果为NULL，则没有使用索引。\n- key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。\n- rows：MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。\n- filtered：表示返回结果的行数占所需读取行数的百分比，filtered的值越大越好。\n\n### 5. 索引使用规则\n\n#### 最左前缀法则\n\n如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列，如果跳跃某一列，索引将部分失效（后面的字段索引失效）。\n\n#### 范围查询\n\n联合索引中，出现范围查询（<、>），范围查询右侧的列索引失效。\n\n#### 索引列运算\n\n在索引列上进行运算操作，索引将失效。\n\n#### 字符串不加引号\n\n字符串类型字段使用时，不加引号，索引会失效。\n\n#### 模糊查询\n\n如果仅仅是尾部模糊匹配，索引不会失效，如果是头部模糊匹配，索引失效。\n\n#### or连接条件\n\n用or分隔开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引后不会被用到。\n\n#### 数据分布影响\n\n如果 MySQL 评估使用索引比全表扫描更慢，则不使用索引。\n\n#### SQL提示\n\n在 SQL 语句中加入一些人为的提示来达到优化操作的目的。\n\nuse index:\n\n```SQL\nselect * from tb_user use index(idx_user_pro) where ...\n```\n\nignore index:\n\n```SQL\nselect * from tb_user ignore index(idx_user_pro) where ...\n```\n\nforce index:\n\n```SQL\nselect * from tb_user force index(idx_user_pro) where ...\n```\n\n#### 覆盖索引\n\n使用 select * 非常容易出现回表查询，避免\n\n#### 前缀索引\n\n当字段类型为字符串（varchar，text 等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘 IO，影响查询效率，此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。\n\n语法：\n\n```SQL\ncreate index idx_xxxx on table_name(column(n));\n```\n\n前缀长度可以根据字段的选择性来决定：\n\n```SQL\nselect count(distinct substring(email,1,n))/count(*) from tb_user\n```\n\n#### 单列索引与联合索引\n\n在业务场景中，如果存在多个查询条件，考虑针对查询字段建立索引时，建议建立联合索引，而非单列索引。\n\n### 6. 索引设计原则\n\n- 针对数据量大，且查询频繁的表建立索引。\n- 针对常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。\n- 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。\n- 如果是字符串类型的字段，字段的长度较长，可以针对字段的特点，建立前缀索引。\n- 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。\n- 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。\n- 如果索引列不能存储 NULL 值，请在创建表时使用 NOT NULL 约束它。当优化器知道每列是否包含 NULL 值时，它可以更好地确定哪个索引最有效地用于查询。\n\n## 三、SQL 优化\n\n### 1. 插入数据\n\ninsert 优化\n\n- 批量插入\n\n    ```SQL\n    insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');手动提交事务\n    ```\n\n- 手动提交事务\n\n    ```SQL\n    start transaction;\n    insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');\n    insert into tb_test values(4,'Tom'),(5,'Cat'),(6,'Jerry');\n    insert into tb_test values(7,'Tom'),(8,'Cat'),(9,'Jerry');\n    commit;\n    ```\n\n- 主键顺序插入\n\n- 大批量插入数据\n\n    ```SQL\n    # 客户端链接服务端时，加上参数 --local-infile\n    mysql --local-infile -u root -p\n    # 设置全局参数 local_infile 为 1，开启从本地加载文件导入数据的开关\n    set global local_infile=1;\n    # 执行 load 指令将准备好的数据，加载到表结构中\n    load data local infile '/root/sql1.log' into table 'tb_user' fields terminated by ',' lines terminated by '\\n';\n    ```\n\n### 2. 主键优化\n\n数据组织方式：在 InnoDB 存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table），即 IOT。\n\n页可以为空，也可以填充一般，也可以填充 100%。每个页包含了 2~N 行数据（如果一行数据比较大，会行溢出），根据主键排列。\n\n**页分裂、页合并**\n\n主键设计原则：\n\n- 尽量降低主键长度\n- 插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键\n- 尽量不要使用 uuid 做主键或者其他自然主键\n- 避免对主键的修改\n\n### 3. order by 优化","tags":["Databases","MySQL"],"categories":["数据库"]},{"title":"MySQL 学习笔记基础篇","url":"/2024/11/22/Mysql-learning-1/","content":"\n数据库基础学习\n\n<!--more-->\n\n## 一、MySQL 数据库的数据模型\n\n**用户**登录访问 $MySQL$ **数据库**，**数据库**下存放若干**表**，**表**中存储**信息**。\n\n## 二、SQL 语法——通用\n\n1. 单行或多行书写，分号结尾；\n2. 可空格、缩进；\n3. $MySQL$ 的 $SQL$ 语句不区分大小写，关键字建议大写；\n4. 单行注释用 ``-- something`` 或 ``# something``；\n5. 多行注释用 ``/* something */``。\n\n## 三、SQL 语法——DDL\n\n$DDL$ 全称 $Data\\ Definition\\ Language$，数据定义语言，用来定义数据库对象（数据库、表、字段）。\n\n- 数据库-查询\n\n    - 查询所有数据库\n\n        ``SHOW DATABASES;`` \n\n    - 查询当前数据库\n\n        ``SELECT DATABASE();`` \n\n- 数据库-创建\n\n    ``CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则];`` \n\n- 数据库-删除\n\n    ``DROP DATABASE [IF EXISTS] 数据库名;`` \n\n- 数据库-使用\n\n    ``USE 数据库名;`` \n\n- 表-查询\n\n    - 查询当前数据库所有表\n\n        ``SHOW TABLES;`` \n\n    - 查询表结构\n\n        ``DESC 表名;`` \n\n    - 查询指定表的建表语句\n\n        ``SHOW CREATE TABLE 表名;`` \n\n- 表-创建\n\n    ```sql\n    CREATE TABLE 表名(\n    \t字段1 字段1类型 [COMMENT 字段1注释],\n        字段2 字段2类型 [COMMENT 字段2注释],\n        字段3 字段3类型 [COMMENT 字段3注释],\n        ......\n        字段n 字段n类型 [COMMENT 字段n注释]\n    ) [comment 表注释];\n    ```\n\n- 表-修改\n\n    - 添加字段\n\n        ``ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];`` \n\n    - 修改数据类型\n\n        ``ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);`` \n\n    - 修改字段名和字段类型\n\n        ``ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];`` \n\n    - 删除字段\n\n        ``ALTER TABLE 表名 DROP 字段名;`` \n\n    - 修改表名\n\n        ``ALTER TABLE 表名 RENAME TO 新表名;`` \n\n- 表-删除\n\n    - 删除表\n\n        ``DROP TABLE [IF EXISTS] 表名;`` \n\n    - 删除指定表，并重新创建该表\n\n        ``TRUNCATE TABLE 表名;`` \n\n**补充**：$MySQL$ 的数据类型\n\n1. 数值类型\n\n<table>\n    <tbody align=center>\n        <tr>\n            <th>分类</th>\n            <th>类型</th>\n            <th>大小</th>\n            <th>有符号(SIGNED)范围</th>\n            <th>无符号(UNSIGNED)范围</th>\n        </tr>\n        <tr>\n            <th rowspan=\"8\">数值类型</th>\n            <td>TINYINT</td>\n            <td>1 byte</td>\n            <td>[-128,127]</td>\n            <td>[0,255]</td>\n        </tr>\n        <tr>\n        \t<td>SMALLINT</td>\n            <td>2 byte</td>\n            <td>[-32768,32767]</td>\n            <td>[0,65535]</td>\n        </tr>\n        <tr>\n        \t<td>MEDIUMINT</td>\n            <td>3 byte</td>\n            <td>[-8388608,8388607]</td>\n            <td>[0,16777215]</td>\n        </tr>\n        <tr>\n        \t<td>INT/INTEGER</td>\n            <td>4 byte</td>\n            <td>[-2147483648,2147483647]</td>\n            <td>[0,4294967295]</td>\n        </tr>\n        <tr>\n        \t<td>BIGINT</td>\n            <td>8 byte</td>\n            <td>[-2^63,2^63-1]</td>\n            <td>[0,2^64-1]</td>\n        </tr>\n        <tr>\n        \t<td>FLOAT</td>\n            <td>4 byte</td>\n            <td>/</td>\n            <td>/</td>\n        </tr>\n        <tr>\n        \t<td>DOUBLE</td>\n            <td>8 byte</td>\n            <td>/</td>\n            <td>/</td>\n        </tr>\n        <tr>\n        \t<td>DECIMAL</td>\n            <td> </td>\n            <td>/</td>\n            <td>/</td>\n        </tr>\n    </tbody>\n</table>\n\n关于 $DECIMAL$ 类型定义时传入两个参数 $(M,D)$，$M$ 表示精度，有效位数，$D$ 表示标度，小数位数。\n\n2. 字符串类型\n\n<table>\n    <tbody align=center>\n    \t<tr>\n        \t<th>分类</th>\n            <th>类型</th>\n            <th>大小</th>\n            <th>描述</th>\n        </tr>\n        <tr>\n        \t<th rowspan=\"10\">字符串类型</th>\n            <td>CHAR</td>\n            <td>0-255 bytes</td>\n            <td>定长字符串</td>\n        </tr>\n        <tr>\n        \t<td>VARCHAR</td>\n            <td>0-65535 bytes</td>\n            <td>变长字符串</td>\n        </tr>\n        <tr>\n            <td>TINYBLOB</td>\n            <td>0-255 bytes</td>\n            <td>不超过255个字符的二进制数据</td>\n        </tr>\n        <tr>\n        \t<td>TINYTEXT</td>\n            <td>0-255 bytes</td>\n            <td>短文本字符串</td>\n        </tr>\n        <tr>\n        \t<td>BLOB</td>\n            <td>0-65535 bytes</td>\n            <td>二进制形式的长文本数据</td>\n        </tr>\n        <tr>\n        \t<td>TEXT</td>\n            <td>0-65535 bytes</td>\n            <td>长文本数据</td>\n        </tr>\n        <tr>\n        \t<td>MEDIUMBLOB</td>\n            <td>0-16777215 bytes</td>\n            <td>二进制形式的中等长度文本数据</td>\n        </tr>\n        <tr>\n        \t<td>MEDIUMTEXT</td>\n            <td>0-16777215 bytes</td>\n            <td>中等长度文本数据</td>\n        </tr>\n        <tr>\n        \t<td>LONGBLOB</td>\n            <td>0-4294967295 bytes</td>\n            <td>二进制形式的极大文本数据</td>\n        </tr>\n        <tr>\n        \t<td>LONGTEXT</td>\n            <td>0-4294967295 bytes</td>\n            <td>极大文本数据</td>\n        </tr>\n    </tbody>\n</table>\n\n后面传参是字符串长度\n\n3. 日期类型\n\n<table>\n    <tbody align=center>\n    \t<tr>\n            <th>分类</th>\n            <th>类型</th>\n            <th>大小</th>\n            <th>范围</th>\n            <th>格式</th>\n            <th>描述</th>\n        </tr>\n        <tr>\n        \t<th rowspan=\"5\">日期类型</th>\n            <td>DATE</td>\n            <td>3</td>\n            <td>1000-01-01 至 9999-12-31</td>\n            <td>YYYY-MM-DD</td>\n            <td>日期值</td>\n        </tr>\n        <tr>\n        \t<td>TIME</td>\n            <td>3</td>\n            <td>-838:59:59 至 838:59:59</td>\n            <td>HH:MM:SS</td>\n            <td>时间值或持续时间</td>\n        </tr>\n        <tr>\n        \t<td>YEAR</td>\n            <td>1</td>\n            <td>1901 至 2155</td>\n            <td>YYYY</td>\n            <td>年份值</td>\n       \t</tr>\n       \t<tr>\n        \t<td>DATETIME</td>\n            <td>8</td>\n            <td>1000-01-01 00:00:00 至 9999-12-31 23:59:59</td>\n            <td>YYYY-MM-DD HH:MM:SS</td>\n            <td>混合日期和时间值</td>\n        </tr>\n        <tr>\n        \t<td>TIMESTAMP</td>\n            <td>4</td>\n            <td>1970-01-01 00:00:01 至 2038-01-19 03:14:07</td>\n            <td>YYYY-MM-DD HH:MM:SS</td>\n            <td>混合日期和时间值，时间戳</td>\n        </tr>\n\t</tbody>\n</table>\n\n## 四、SQL 语法——DML\n\n$DML$ 全称 $Data\\ Manipulation\\ Language$，数据操作语言，用来对数据库表中的数据进行增删改。\n\n- 添加数据\n\n    - 给指定字段添加数据\n\n        ``INSERT INTO 表名(字段名1, 字段名2, ...) VALUES(值1, 值2, ...); `` \n\n    - 给全部字段添加数据\n\n        ``INSERT INTO 表名 VALUE(值1, 值2, ...);`` \n\n    - 批量添加数据\n\n        ``INSERT INTO 表名(字段名1, 字段名2, ...) VALUE(值1, 值2, ...), (值1 值2, ...), (值1, 值2, ...);`` \n\n        ``NSERT INTO 表名 VALUE(值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);`` \n\n- 修改数据\n\n    ``UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [WHERE 条件];`` \n\n- 删除数据\n\n    ``DELETE FROM 表名 [WHERE 条件];`` \n\n## 五、SQL 语法——DQL\n\n$DQL$ 全称 $Data\\ Query\\ Language$，数据查询语言，用来查询数据库中表的记录。\n\n````sql\nSELECT [DISTINCT]\n\t字段1 [AS 别名1], 字段2 [AS 别名2], 字段3 [AS 别名3], ...\nFROM\n\t表名列表\nWHERE\n\t条件列表\nGROUP BY\n\t分组字段列表\nHAVING\n\t分组后条件列表\nORDER BY\n\t字段1 ASC/DESC, 字段2 ASC/DESC;\nLIMIT\n\t起始索引, 查询记录数;\n````\n\n**补充**：聚合函数\n\n统计数量 ``count`` \n\n最大值 ``max`` \n\n最小值 ``min`` \n\n平均值 ``avg`` \n\n求和 ``sum`` \n\n## 六、SQL 语法——DCL\n\n$DCL$ 全称 $Data\\ Control\\ Language$，数据控制语言，用来创建数据库用户、控制数据库的访问权限。\n\n- 管理用户\n\n    - 查询用户\n\n        ``USE mysql;`` \n\n        ``SELECT * FROM user;`` \n\n    - 创建用户\n\n        ``CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';`` \n\n    - 修改用户密码\n\n        ``ALTER USER '用户名'@'主机名' IDENTIFIED WITH caching_sha2_password BY '新密码';`` \n\n    - 删除用户\n\n        ``DROP USER '用户名'@'主机名'; `` \n\n- 权限控制\n\n    - 查询权限\n\n        ``SHOW GRANTS FOR '用户名'@'主机名';`` \n\n    - 授予权限\n\n        ``GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';`` \n\n    - 撤销权限\n\n        ``REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';`` \n\n## 七、函数\n\n1. 字符串函数\n\n    字符串拼接：``CONCAT(S1,S2,...,Sn)`` \n\n    字符串转为小写：``LOWER(str)`` \n\n    字符串转为大写：``UPPER(str)`` \n\n    左填充：``LPAD(str,n,pad)`` \n\n    右填充：``RPAD(str,n,pad)`` \n\n    去字符串头尾空格：``TRIM(str)`` \n\n    取子字符串：``SUBSTRING(str,start,len)`` \n\n2. 数值函数\n\n    向上取整：``CEIL(x)`` \n\n    向下取整：``FLOOR(x)`` \n\n    取模：``MOD(x)`` \n\n    0~1随机数：``RAND()`` \n\n    四舍五入，保留小数：``ROUND(x,y)`` \n\n3. 日期函数\n\n    当前日期：``CURDATE()`` \n\n    当前时间：``CURTIME()`` \n\n    当前日期和时间：``NOW()`` \n\n    获取年份：``YEAR(date)`` \n\n    获取月份：``MONTH(date)`` \n\n    获取日期：``DAY(date)`` \n\n    一个日期加上一个时间间隔：``DATE_ADD(date,INTERVAL expr type)`` \n\n    两个时间之间的天数：``DATEDIFF(date1,date2)`` \n\n4. 流程函数\n\n    ``IF(value,t,f)`` $value$ 为 $true$，返回 $t$，否则返回 $f$ \n\n    ``IFNULL(value1,value2)`` $value1$ 不为空输出 $value1$，否则 $value2$ \n\n    ``CASE WHEN [val1] THEN [res1] ... ELSE [dafault] END`` 如果 $val1$ 为 $true$，返回 $res1$，……，否则返回 $default$ 默认值\n\n    ``CASE [expr] WHEN [val1] THEN [res1] ... ELSE [default] END`` 如果 $expr$ 的值等于 $val1$，返回 $res1$，……，否则返回 $default$ 默认值\n\n## 八、约束\n\n约束是作用于表中字段上的规则，用于限制存储在表中的数据。\n\n- 非空约束：限制该字段的数据不能为 $null$，关键字 ``NOT NULL`` \n- 唯一约束：保证该字段的所有数据都是唯一、不重复的，关键字 ``UNIQUE`` \n- 主键约束：主键是一行数据的唯一标识，要求非空且唯一，关键字 ``PRIMARY KEY``，自增关键字 ``AUTO_INCREMENT`` \n- 默认约束：保存数据时，如果未指定该字段的值，则采用默认值，关键字 ``DEFAULT`` \n- 检查约束：保证字段值满足某一个条件，关键字 ``CHECK`` \n- 外键约束：用来让两张表的数据之间建立连接，保证数据的一致性和完整性，关键字 ``FOREIGN KEY`` \n\n外键约束语法：\n\n```SQL\nCREATE TABLE 表名(\n\t字段名 数据类型,\n   \t......\n    [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主表字段名)\n);\n```\n\n```sQL\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表字段名);\n```\n\n外键删除/更新行为：\n\n- NO ACTION：当在主表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新\n- RESTRICT：同上\n- CASCADE：当在主表中删除/更新对应记录时，首先检查该纪录是否有对应外键，如果有，则也删除/更新外键在子表中的记录\n- SET NULL：当在主表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为 $NULL$（要求子表字段可以设置为 $NULL$）\n- SET DEFAULT：主表有变更时，子表将外键列设置成一个默认的值（Innodb不支持）\n\n```SQL\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表字段名) ON UPDATE 关键字 ON DELETE 关键字;\n```\n\n## 九、多表查询\n\n使用 ``SELECT * from A,B`` 查询出来的是 $A$ 表和 $B$ 表的笛卡尔积，需要 $WHERE$ 关键字提取需要的项，去除不需要的项\n\n### 1. 内连接\n\n内连接查询的是两张表交集的部分\n\n- 隐式内连接\n\n    ``SELECT 字段列表 FROM 表1,表2 WHERE 条件…;`` \n\n- 显式内连接\n\n    ``SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件…;`` \n\n### 2. 外连接\n\n左外连接包括左表所有数据，右外连接包括右表所有数据\n\n- 左外连接\n\n    ``SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件…;`` \n\n- 右外连接\n\n    ``SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件…;`` \n\n### 3. 自连接\n\n可外可内\n\n``SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件…;`` \n\n### 4. 联合查询\n\n把查询结果合并起来\n\n```SQL\nSELECT 字段列表 FROM 表A …\nUNION [ALL]\nSELECT 字段列表 FROM 表B …;\n```\n\n``UNION`` 去重\n\n``UNION ALL`` 不去重\n\n### 5. 子查询\n\n- 标量子查询\n- 列子查询\n- 行子查询\n- 表子查询\n\n## 十、事务\n\n- 查看事务提交方式\n\n    ``SELECT @@autocommit;`` \n\n- 设置事务提交方式（设置成不自动提交）\n\n    ``SET @@autocommit = 0;`` \n\n- 提交事务\n\n    ``COMMIT;`` \n\n- 回滚事务\n\n    ``ROLLBACK;`` \n\n- 事务四大特性（ACID）\n    - 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。\n    - 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。\n    - 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。\n    - 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。\n\n- 并发事务问题\n\n    - 脏读：一个事务读到另外一个事务还没有提交的数据。\n    - 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同。\n    - 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在。\n\n- 事务隔离级别\n\n    - Read uncommitted：三个并发事务问题都会出现\n\n    - Read committed：解决了脏读，没有解决不可重复读和幻读\n\n    - Repeatable Read(默认)：解决了脏读和不可重复读，没有解决幻读\n\n    - Serializable：三个问题都解决了\n\n    - 查看事务隔离级别\n\n        ``SELECT @@TRANSACTION_ISOLATION;`` \n\n    - 设置事务隔离级别（``SESSION`` 只管当前会话，``GLOBAL`` 管全局）\n\n        ``SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE};`` \n","tags":["Databases","MySQL"],"categories":["数据库"]},{"title":"数学建模——数据预处理","url":"/2023/12/24/modeling-prework/","content":"\n写在前面：好久没更新博客了，不知道因为什么原因，考试周快过去了，插空更一个队长分享的一个课程的总结。\n\n<!--more-->\n\n边听课边写线代卷子，听了个大概，主要讲的是针对大数据题做的数据预处理专题，深有体会，经过数理大赛和亚太杯的胡乱搞，感觉前期的数据预处理过程和结果对后期的建模确实有比较重要的影响，故想写一些东西加深印象。\n\n数据预处理一般包括：数据集成、数据规约、数据清洗、数据变换，下面挨个来说\n\n## 数据集成\n\n数据集成一般指把来自不同数据源、用不同表示规则表示的数据整合为同一类型、统一表示规则的数据方便处理。\n\n### 实体识别问题\n\n就比如说最近一次的亚太赛的 $A$ 题，要求对图片中苹果的个数、位置、重量、成熟程度进行识别，当时我们使用的方法是基于数连通块个数的方法再进行优化，采用的数据集成方法就是分别读取图片中每个像素点的 $RGB$ 值，然后整合到一个表格中，再进行下一步。\n\n实体识别问题再提一嘴，可以使用 *labelimg* 来对图片进行标注框画，建模一般使用深度学习模型\n\n### 数据字段问题\n\n刚好对应数理大赛的赛题，房价预测模型，房子的属性参数不止有数值型数据，还有非数值型数据比如字符串数据，如果该标签为分类变量，我们当时处理成了 $one-hot$ 变量数据，大大增加了标签数量，非分类变量一般与房价关联程度不高，直接删去该标签 \n\n### 冗余和相关性分析\n\n如果一个标签能够通过其他标签推出或表示，即相关程度大，那么这个标签就是冗余数据。判断冗余数据可以使用相关性分析。\n\n#### 皮尔逊相关性分析\n\n#### 斯皮尔曼相关性分析\n\n### 元组重复\n\n\n\n","tags":["数学建模"],"categories":["算法"]},{"title":"最优化理论的三大非经典算法","url":"/2023/10/30/three-algorithms-optimization/","content":"\n写在前面：要打数学建模，学点好玩的\n\n<!--more-->\n\n## 模拟退火\n\n是一个随机化算法\n\n借鉴固体的退火过程\n\n最核心的地方在于，对前一状态进行随机扰动，如果更优就作为当前状态，如果不优，有一定概率取为当前状态\n\n局部最优的地方不一定全局最优，所以有一定概率从局部最优跳出，去寻找全局最优\n\n参数有：\n\n**T_begin** : 初始温度\n\n**T_end** : 结束温度\n\n**$\\alpha$** : 退火速率系数\n\n**T** : 当前温度\n\n以上是控制随机化过程中对状态的遍历程度完全/不完全，具体来说，每得到一个随机答案，当前温度都会乘 $\\alpha$，直到低于结束温度\n\n在随机扰动时，会有 **L** : 马尔科夫链长度\n\n在取答案(以越小越优为例)时，设第 $n$ 个状态的答案 $ans_n$，定义 $p$ 如下：\n$$\np=\\begin{cases}\n1,&ans_{n+1}<ans_n\n\\\\exp(-\\frac{ans_{n+1}-ans_n}{T}),&ans_{n+1}\\geq ans_n\n\\end{cases}\n$$\n在 $[0,1]$ 之间随机取一个 $\\epsilon$， 若 $p>\\epsilon$，第 $n+1$ 个状态将被接受\n\n解决 $01$ 背包问题：\n\n```matlab\n% 模拟退火\nclear;\nclc;\nclose all;\nN=input('有多少物品：');\nW=input('背包承重：');\nw=input('依次输入物品重量：');\nv=input('依次输入物品价值：');\n% init\n\nalpha=0.95;\nt_begin=200;\nt_end=0.1;\nt=t_begin;\nsolution_new=ones(1,length(w));\nsolution_current=zeros(1,length(w));\nvalue_current=0;\nvalue_best=0;\nsolution_best=solution_current;\ncounter=0;\n\nwhile(t>t_end)\n    \n    counter=counter+1;\n\n    for i = 1:100\n\n        index=randi([1,length(w)],1,1);\n        solution_new(1,index)=~solution_new(1,index);\n        \n        solution_new.*w; % 每个位置相乘\n\n        while sum(solution_new.*w)>W\n            index=randi([1,length(w)],1,1);\n            solution_new(1,index)=~solution_new(1,index);\n        end\n\n        value_new=sum(solution_new.*v);\n\n        possibility=exp((value_new-value_current)/t);\n        if possibility>rand \n            value_current=value_new;\n            solution_current=solution_new;\n        else\n            solution_new=solution_current;\n        end\n\n        if value_current>value_best\n            value_best=value_current;\n            solution_best=solution_current;\n        end\n\n    end\n\n    value_list(counter,:)=value_best;\n    solution_list(counter,:)=solution_best;\n    t=t*alpha;\nend\n\nfigure(3);\nplot(value_list);\nxlabel('迭代次数');\nylabel('目标函数值');\ntitle('适应度进化曲线');\nfprintf('最大价值：%f，货物重量%d\\n',value_best,sum(solution_best.*w));\ndisp(['解：',num2str(solution_best)]);\n```\n\n## 遗传算法\n\n\n\n## 神经网络\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["数学建模","Matlab","模拟退火","遗传算法","神经网络"],"categories":["算法"]},{"title":"【GDCPC2023】Base Station Construction","url":"/2023/10/18/[GDCPC2023]Base-Station-Construction/","content":"\n写在前面：没什么好写的\n\n<!--more-->\n\n## 1 题意\n\n给出一个长度为 $n$ 的序列 ${a_i}$ 以及 $m$ 个区间 $[l_i,r_i]$，在其中选择若干个数，使得满足在每个区间 $[l_i,r_i]$ 中至少有一个选择的数，求满足条件的选择的数的最小值\n\n## 2 题解\n\n首先可以证明，两个区间有覆盖关系时，我们可以只考虑小区间，舍去大区间，因为不管怎么样小区间里都会有被选的数，此时，大区间自然满足条件。\n\n我们设 $f_i$ 为考虑到第 $i$ 个数且选第 $i$ 个数的最小代价，设 $g_i$ 为考虑到第 $i$ 个数的最小代价。注意这里考虑到第 $i$ 个数时，我们只满足完整的区间，位置 $i$ 之后还有部分的区间暂时不算入，所以我们当遇到区间右端点才计算上这个区间的限制\n\n可以写出状态转移方程：\n$$\n\\begin{aligned}\nf_i&=g_{i-1}+a_i&\\\\\ng_i&=g_{i-1}&i\\neq r_j\\\\\ng_i&=\\min_{k=l_j}^{r_j} f_k&i=r_j\n\\end{aligned}\n$$\n于是就可以转移了，区间最小值可以无脑用线段树 $log$ 掉，复杂度 $O((n+m)\\log n)$ \n\n## 3 代码\n\n```c++\n//头\nusing namespace std;\n#define N 1000010\n#define int long long\ntemplate<typename T>\ninline void read(T &x){\n    x=0;bool flg=0;char c=getchar();\n    for(;!isdigit(c);c=getchar()) if(c=='-') flg=1;\n    for(;isdigit(c);c=getchar()) x=x*10+(c^48);\n    if(flg) x=-x;\n}\nint n,m;\nint t;\nint a[N];\nint l[N];\nint g[N];\nint f[4*N];\nvoid pushup(int x){\n    f[x]=min(f[x<<1],f[x<<1|1]);\n}\nvoid build(int x,int l,int r){\n    if(l==r) return f[x]=0,void();\n    int mid=(l+r)>>1;\n    build(x<<1,l,mid);\n    build(x<<1|1,mid+1,r);\n    pushup(x);\n}\nvoid change(int x,int l,int r,int o,int v){\n    if(l==r) return f[x]+=v,void();\n    int mid=(l+r)>>1;\n    if(o<=mid) change(x<<1,l,mid,o,v);\n    else change(x<<1|1,mid+1,r,o,v);\n    pushup(x);\n}\nint query(int x,int l,int r,int ql,int qr){\n    if(ql<=l&&qr>=r) return f[x];\n    int mid=(l+r)>>1,res=0x3f3f3f3f3f3f3f;\n    if(ql<=mid) res=min(res,query(x<<1,l,mid,ql,qr));\n    if(qr>mid) res=min(res,query(x<<1|1,mid+1,r,ql,qr));\n    return res;\n}\nsigned main(){\n    read(t);\n    while(t--){\n        read(n);\n        for(int i=1;i<=n;i++) read(a[i]),g[i]=0,l[i]=0;\n        read(m);\n        for(int i=1;i<=m;i++){\n            int a,b;\n            read(a),read(b);\n            if(!l[b]) l[b]=a;\n            else l[b]=max(a,l[b]);\n        }\n        build(1,1,n);\n        for(int i=1,j=0;i<=n;i++){\n            change(1,1,n,i,g[i-1]+a[i]);\n            if(l[i]&&l[i]>j) g[i]=query(1,1,n,l[i],i),j=l[i];\n            else g[i]=g[i-1];\n        }\n        cout<<g[n]<<endl;\n    }\n    return 0;\n}\n```\n\n","tags":["线段树","DP"],"categories":["算法"]},{"title":"牛客挑战赛48C","url":"/2023/10/18/newcoder48C/","content":"\n就非得写点东西吗\n\n<!--more-->\n\n## 题意\n\n$n$ 个点，连 $m$ 条边，形成 $n-m$ 棵树，每种方案贡献为这 $n-m$ 棵树大小之积，求所有方案贡献和\n\n## 题解\n\n根据题意，这 $n-m$ 棵树肯定为无根树 \n\n首先考虑要生成一棵 $n$ 结点无根树，根据 $prufer$ 序列，可以很轻松地求出方案数，如果算上每个方案的贡献，直接 $\\times n$ 就好了，答案是 $n^{n-2} \\times n=n^{n-1}$  \n\n发现这跟构造有根树的方案数一样，所以我们可以做一个题意转换，我们令每种方案里确定每棵树的根节点，那么方案数就跟贡献和一样了\n\n我们假设一个虚点 $0$，令它连接每棵树的根节点，现在就可以算了\n\n一共有 $n+1$ 个点，$prufer$ 序列长度为 $n-1$，其中点 $0$ 的度是知道的，有 $n-m$，所以在 $prufer$ 序列中，$0$ 应该出现 $n-m-1$ 次，先选 $C^{n-m-1}_{n-1}$，然后剩下的数都是在 $1 \\sim n$，再 $\\times n^{m}$ 就是答案 \n\n答案是 $C^{n-m-1}_{n-1}\\times n^{m}$，时间复杂度 $O(m)$ \n\n## 代码\n\n```c++\n#define int long long\n\nconst int Mod=1e9+7;\nint n,m;\nint ans=1;\n\nint fpow(int a,int b){\n    int res=1;\n    for(;b;b>>=1,a=a*a%Mod) if(b&1) res=res*a%Mod;\n    return res%Mod;\n}\n\nsigned main(){\n\n    read(n),read(m);\n\n    for(int i=1;i<=m;i++) (ans*=i)%=Mod;\n    ans=fpow(ans,Mod-2);\n    (ans*=fpow(n,m))%=Mod;\n    for(int i=n-m;i<=n-1;i++) (ans*=i)%=Mod;\n\n    cout<<ans<<endl;\n\n    return 0;\n}\n```","tags":["思维题","prufer序列","计数题"],"categories":["算法"]},{"title":"有关完全图中生成树数量问题的思考","url":"/2023/10/17/number-of-STs-on-CG/","content":"\n写在前面：在复健矩阵的时候发现了 `[NOI2007]生成树计数` 这个题，遂起兴研究生成树计数\n\n<!--more-->\n\n> $n$ 个结点的环的生成树个数为 $n$ \n>\n> $n$ 个结点的完全图的生成树个数为 $n^{n-2}$ \n\n第一句话很好理解，只要去除环中的任意一条边，就是一棵生成树\n\n第二句话也叫 $Cayley$ 公式，证明需要用到 $Prufer$ 序列的东西，顺便提一嘴，$Prufer$ 序列就是为证明 $Cayley$ 公式而诞生的\n\n犹记两年前 $zzz$ 讲题时给我们讲到过这个东西，但是已经忘掉了\n\n## Prufer Code\n\n以下提到的树都是**有标号无根树** \n\n每棵结点数大于 $1$ 的树都对应唯一一个 $Prufer$ 序列，每个 $Prufer$ 序列也唯一对应一棵结点数大于 $1$ 的树，两者为双射关系\n\n由树构造 $prufer$ 序列步骤如下：\n\n1. 找到叶子结点中编号最小的，记作 $p$，将 $p$ 的父结点 $f$ 加入序列\n2. 删去 $p$ 结点\n3. 重复步骤 1. 和 2. ，直到整棵树只剩下两个结点，结束\n\n显然，若整棵树有 $n$ 个结点，那么该树对应的 $prufer$ 序列长度应该为 $n-2$ \n\n由构造过程，可以得出两个结论：\n\n1. 结点 $n$ 最后一定没有被删除\n2. 每个结点的度是序列中该结点出现次数 $+1$ \n\n根据构造过程，相似地，可以得出由 $prufer$ 序列构造树的方法：\n\n1. 根据度数为 $1$ 确定当前的叶子结点，找出叶子结点中编号最小的结点，记作 $p$，将 $p$ 的父结点设为序列中第一个没有遍历过的结点 $f$ \n2. 删去 $p$，$f$ 度数 $-1$，如果 $f$ 度数为 $1$，那么把其加入叶子节点集合中\n3. 重复 1. 和 2. ，最后会剩下两个叶子结点，将其连接，结束\n\n由每一步构造的唯一性以及每一步反构造的唯一性，由反证法可以得出\n\n1. 不存在两个 $prufer$ 序列对应同一棵树\n2. 不存在两棵树对应同一个 $prufer$ 序列\n\n设 $A$ 为所有树构成的集合，$B$ 为所有 $prufer$ 序列构成的集合，由 1. 得 $|A|\\geq |B|$，由 2. 得 $|A|\\leq |B|$，即 $|A|=|B|$，得证\n\n若要钦定根，最后可以添加一个根节点，序列长度变为 $n-1$，相似地，可以唯一确定一棵有标号有根树\n\n### 更好的构造与反构造方法\n\n[模板](https://www.luogu.com.cn/problem/P6086) \n\n用代码模拟构造和反构造当然可以用小根堆，时间复杂度 $O(n\\log n)$ \n\n还有一种更为快速的方法\n\n构造：\n\n1. 找到编号最小的叶子结点 $p$，父结点 $f$ 加入序列\n2. 若删去 $p$ 后，$f$ 变为叶子结点，且编号比 $p$ 小，则 $f$ 为当前编号最小的叶子结点，直接令 $p$ 为 $f$，重复操作 1. 和 2. \n3. 若不满足 2. ，将 $p$ 自增，直到找到下一个未删除的叶子结点\n\n$p$ 最多自增 $n-2$ 次，时间复杂度 $O(n)$ \n\n```C++\nint p;\nfor(int i=1;i<=n;i++) if(d[i]==1){p=i;break;}\n\nvector<int> prufer;\nint l=p;\nwhile(prufer.size()<n-2){\n    int f=fa[l];\n    prufer.push_back(f);\n    d[f]--;\n    if(d[f]==1&&f<p) l=f;\n    else{\n        p++;\n        while(d[p]!=1) p++;\n        l=p;\n    }\n}\n```\n\n反构造：同上\n\n看代码\n\n```C++\nint p;\nfor(int i=1;i<=n;i++) if(d[i]==1){p=i;break;}\n\nint l=p;\nfor(int i=1;i<=n-2;i++){\n    int f;\n    f=fa[l]=prufer[i];\n    d[f]--;\n    if(d[f]==1&&f<p) l=f;\n    else{\n        p++;\n        while(d[p]!=1) p++;\n        l=p;\n    }\n}\nfa[l]=n;//最后剩下的两个点\n```\n\n---\n\nOK\n\n学完 $Prufer$ 序列后就能证明 $Cayley$ 公式了，由于每个序列唯一对应一棵树，那么长度为 $n-2$ 的序列的总个数就是 $n$ 个点的完全图的生成树个数，也就是 $n^{n-2}$ 个\n\n有根树对应 $Prufer$ 序列长度为 $n-1$，数量为 $n^{n-1}$ 个\n\n来点数学\n\n如果给定 $n$ 并固定每个点的度数，那么能形成的有标号无根树有多少？\n\n考虑 $Prufer$ 序列，先阶乘再去重就好啦，设第 $i$ 个点度数为 $d_i$，答案是 $\\frac{(n-2)!}{\\prod^{n}_{i=1}(d_i-1)!}$ \n\n[板子](https://www.luogu.com.cn/problem/P2290)\n\n完全二分图生成树个数？\n\n左部点 $n$ 个，右部点 $m$ 个\n\n构造 $Prufer$ 序列最后剩下的两个点一定是左部点一个右部点一个，考虑删去的点，删去一个左部点一定会往序列填一个右部点，删去一个右部点一定会往序列填一个左部点，最后的序列中左部点的数量为 $m-1$ 个，右部点数量为 $n-1$ 个，$Prufer$ 序列共有 $n^{m-1}m^{n-1}$ 个，答案也是这个\n\n以上 $n=1$ 都需要特判o\n\n---\n\n$zzz$ 当时找了几道题，我去做做\n\nCF917D（这道题也是曾经 $yjc$ 佬课件上的一道题）但是我不会二项式反演\n\nARC106F（需要生成函数，不会捏）\n\n牛客挑战赛48C（这个可以写）\n\nTopCoder SRM697 div1 hard [是这道](https://vjudge.net/problem/TopCoder-14333) （看不懂所以不写）\n\n---\n\n把一些参考放在这里\n\n《Tree-structured Data Regeneration with Network Coding in Distributed Storage Systems》\n\n[【朝夕的ACM笔记】图论-Prufer序列 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/344779506) \n\n[Prufer 序列 - Achtoria - 博客园 (cnblogs.com)](https://www.cnblogs.com/Go7338395/p/14671253.html) \n\n","tags":["生成树","prufer序列"],"categories":["算法"]},{"title":"瞎做到的好题","url":"/2023/10/13/good-problem/","content":"\n写在前面：随便刷到的好题\n\n<!--more-->\n\n## ABC288D\n\n有差分和剩余系的思想，但是不用真的差分，把整个序列按 $\\%k$ 分类，会发现，每次只改变每一类数中的一个，所以要想把所有数消成 $0$，只需要区间内每类数之和相等即可，挨个消，消到最后，一定可以整成 $(a\\ a\\ a\\ a...a |0\\ 0\\ 0...)$ 这种形式\n\n## P9753\n\n跟括号匹配一点都不一样\n\n首先要找两个相邻且相同的字符，然后才能往外消，不妨设 $r_i$ 为第 $i$ 个字符往后最小的 $j$，使 $[i,j]$ 可被消除，然后 $cnt_i$ 表示从第 $i$ 个字符跳多少段最小可消除段才能到不能跳为止，答案就是 $\\sum cnt_i$ \n\n至于 $r_i$ 转移，需要只需要再记录一个 $nxt_{i,j}$ 表示从 $i$ 开始跳可消除段，跳到 $j$ 这个字符的所在下标，倒序遍历就行了\n\n## P5369\n\n数据范围可以看出来是状压 $DP$ \n\n考虑最大前缀和有什么性质，假设从 $a_1$ 加到 $a_k$ 为最大前缀和（$k$ 为满足条件的最大 $k$） ：\n\n1. 在 $[1,k]$ 区间内，所有的后缀和都 $\\geq 0$，除了整体，整体可以 $<0$，因为必须要算上一个数\n\n2. 在 $[k+1,n]$ 区间内 ，所有的前缀和都 $<0$ \n\n所以对于每个状态 $S$，我们记录用全集合内的元素可以满足 1. 的方案数 $f[S]$ 以及可以满足 2. 的方案数 $g[S]$ \n\n对于 $f[S]$ 的特殊情况，我们可以多开一维 $0/1$，记录是否整体 $<0$ \n\n关于转移，用向外转移，即 $g[S|i]+=g[S](sum[S|i]<0)$ 就不会漏辣\n\n## 2022ICPC_Nanjing_D\n\n乐子题，打表看出来最后一定会成为一个不变的序列，只有第一个数与别的数不同，是其他数的两倍，那个 $2022^{1204}$ 可以看成无限次\n\n## 2022CCPC_Guangzhou_H\n\n直接想嘛，记录每个序列里没有的数的奇偶性，A一定填奇数更优，B一定填偶数更优，直接模拟\n\n## 2022ICPC_Jinan_E\n\n每次滑动进出的元素奇偶性相同，考虑根据奇偶性一定相同的元素分块，有 $n\\%k$ 个大小为 $a=\\lfloor\\frac nk \\rfloor +1$ 的块，有 $n-n\\%k$ 个大小为 $b= \\lfloor \\frac nk \\rfloor$ 的块，解 $ax+by=\\lfloor \\frac n2 \\rfloor$ 这个方程，用exgcd求出一个特殊解 $(x_0,y_0)$ 好了，然后通解就是 $(x_0+mb,y_0-ma)$，根据限制分别求出来 $m$ 的取值范围，看看有无交集\n\n是个小nb题\n\n代码放这了\n\n```c++\n//头文件\nint t;\nint n,k,p,q;\n\nint exgcd(int &x,int &y,int a,int b){\n    if(b==0){x=1,y=0;return a;}\n    int g=exgcd(y,x,b,a%b);\n    y-=(a/b)*x;\n    return g;\n}\n\nint main(){\n\n    read(t);\n    while(t--){\n        read(n),read(k);\n        int a,b,x,y;\n\n        a=n/k+1,b=n/k;\n        p=n%k,q=k-p;\n        int g=exgcd(x,y,a,b);\n        if((n/2)%g!=0){cout<<\"No\"<<endl;continue;}\n\n        x*=(n/2)/g;\n        y*=(n/2)/g;\n        \n        int l1=-x/b,l2=(y-q)/a;\n        if(l1*b+x<0) l1++;\n        if(y-l2*a>q) l2++;\n        int r1=(p-x)/b,r2=y/a;\n        if(r1*b+x>p) r1--;\n        if(y-r2*a<0) r2--;\n        if(max(l1,l2)<=min(r1,r2)) cout<<\"Yes\"<<endl;\n        else cout<<\"No\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n## 2022CCPC_Mianyang_G\n\n纯模拟，但是有意思的地方在于对时间复杂度的预测，为什么暴力能过，因为在一个 $n$ 的排列里面，极值最多只可能有 $\\frac n2$ 个，所以模拟最劣复杂度为 $O(n\\log n)$  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["DP","思维题"],"categories":["算法"]},{"title":"CF1882","url":"/2023/09/30/CF1882/","content":"\n写在前面：$2/6$ 睡觉场\n\n<!--more-->\n\n## A\n\n签到，以 $1$ 或 $2$ 开头，扫过去\n\n## B\n\n不太友好的 $B$ \n\n重构了一遍\n\n思想就是试着每次去除集合里的一个元素，并且模拟一下看看连带着会去除多少别的元素，肯定是去除的越少越好，考验码力\n\n## C\n\n写完 $B$ 看完 $C$ 就睡了\n\n","tags":["CodeForces"],"categories":["算法"]},{"title":"CF1879","url":"/2023/09/26/CF1879/","content":"\n写在前面：$3/6$ 的 $div2$ \n\n<!--more-->\n\n## A\n\n签到题，注意读题，特判后直接输出答案\n\n## B\n\n符合条件的摆法，一定满足每行都有或者每列都有\n\n所以按行取一次最小值再按列取一次最小值，输出两次的最小值\n\n## C\n\n小小计数题\n\n预处理出 $C^{i-1}_i$ 以及 $i!$ \n\n如果有连续的一串 $0$ 或 $1$，在 $len$ 个里面取 $len-1$ 个，最后再乘上操作数的阶乘\n\n## D\n\n求全部区间的区间长度 $\\times$ 元素异或和\n\n先考虑 $0\\leq a_i \\leq 1$ 时的做法\n\n求出来异或前缀和，对于一个选定的区间右端点，如果该点异或前缀和为 $0$，那么左端点的异或前缀和只能是 $1$，该区间才对答案有贡献，另外一种情况也一样，于是我们扫一遍序列，分别记录 $0$ 和 $1$ 的个数以及到右端点的距离之和，有点小技巧，每次扫到 $0$ 时就加上 $1$ 对应的距离和，每次扫到 $1$ 时就加上 $0$ 对应的距离和，细节处理一下就好\n\n然后 $a_i<2\\times 10^5$ 就按位拆开分别处理即可\n\n## E\n\n交互题，想假了\n\n一开始的做法：\n\n对于一个点，其连儿子的边都是一种颜色，连父亲的边是另一种颜色，当一个点有大于 $1$ 个儿子时，可以通过数量判断父亲，一棵树都是这样的节点的话，就只需要两种颜色，当一个点只有一个儿子时，就是需要引入另一种颜色，所以我们只需要统计儿子个数之为 $1$ 的点形成的链的最大长度即可，最小颜色就是 $max(2,maxlen+1)$ \n\n实际上，想复杂了\n\n颜色最多 $3$ 种\n\n对于多个儿子的节点直接找 $1$，对于一个儿子的点，相邻边存在的颜色也最多只有 $2$ 种，颜色对 $3$ 取模后就完全可以确定边的优先级\n\n还有一个点就是 $1$ 连儿子的边的颜色可以不相同\n\n贴个代码\n\n```c++\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cstdlib>\n#include<ctime>\n#include<bitset>\n#include<vector>\n#include<climits>\n#include<iomanip>\nusing namespace std;\n#define N 100010\ntemplate<typename T>\ninline void read(T &x){\n    x=0;bool flg=0;char c=getchar();\n    for(;!isdigit(c);c=getchar()) if(c=='-') flg=1;\n    for(;isdigit(c);c=getchar()) x=x*10+(c^48);\n    if(flg) x=-x;\n}\n\nint n,p[N];\nvector<int> e[110];\nint cl[N],mx[110],dmx=0;\n\nvoid dfs1(int x,int c){\n    cl[x]=c;dmx=max(dmx,c);\n    for(auto i:e[x]){\n        if(e[x].size()==1) dfs1(i,c%3+1);\n        else{\n            if(c!=1) dfs1(i,1);\n            else dfs1(i,2);\n        }\n    }\n}\n\nint main(){\n\n    read(n);\n    for(int i=2;i<=n;i++) read(p[i]),e[p[i]].push_back(i);\n\n    for(int i=0;i<e[1].size();i++){\n        dmx=1;\n        dfs1(e[1][i],1);\n        if(dmx==1){mx[i]=1;continue;}\n        else if(dmx==2){mx[i]=2;continue;}\n        else{\n            dmx=2;\n            dfs1(e[1][i],2);\n            if(dmx==2) mx[i]=2;\n            else mx[i]=3;\n        }\n    }\n\n    for(int i=0;i<e[1].size();i++) dmx=max(dmx,mx[i]);\n\n    cout<<dmx<<endl;\n    for(int i=2;i<=n;i++) cout<<cl[i]<<\" \";\n    cout<<endl;\n\n    int op;\n    read(op);\n    while(op==0){\n        int tmp=0;\n        for(int i=1,o=1;i<=dmx;i++,o*=2){\n            int a;\n            read(a);\n            if(a==1) tmp+=o;\n        }\n        if(tmp==1||tmp==3) cout<<1<<endl;\n        else if(tmp==2||tmp==6) cout<<2<<endl;\n        else cout<<3<<endl;\n        read(op);\n    }\n\n    return 0;\n}\n```\n\n## F \n\n问题转换：对于 $x$ 从 $1$ 枚举到 $max(a)$，求出 $h_i\\times \\lceil \\frac{a_i}{x} \\rceil$ 第一大的下标和值以及第二大的值\n\n数论分块+ST表\n\n调死我了\n\n对于每个 $x$，按 $\\lceil \\frac{a_i}{x} \\rceil$ 分块，由调和级数，遍历的复杂度也不会超过 $O(a\\log a)$，于是只需对 $h_i$ 处理\n\n$O(1)$ 查询第一大的下标和值以及第二大的值，$ST$ 表改改就行了，但是💩山代码\n\n贴个代码\n\n```c++\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cstdlib>\n#include<ctime>\n#include<bitset>\n#include<vector>\n#include<climits>\n#include<iomanip>\nusing namespace std;\n#define N 400010\n#define ll long long\ntemplate<typename T>\ninline void read(T &x){\n    x=0;bool flg=0;char c=getchar();\n    for(;!isdigit(c);c=getchar()) if(c=='-') flg=1;\n    for(;isdigit(c);c=getchar()) x=x*10+(c^48);\n    if(flg) x=-x;\n}\n\nint t;\nint mx=0;\nll ans[N];\nint n,f1[30][N],f2[30][N],g[30][N],lg[N]={-1};\nint a[N];\n\nstruct inp{\n    int h,a;\n    int num;\n}p[N];\n\nstruct node{\n    ll idx,k1,k2;\n};\n\nbool cmp(inp a,inp b){\n    return a.a<b.a;\n}\n\nvoid init(){\n    for(int i=1;i<=n;i++) f1[0][i]=p[i].h,f2[0][i]=0,lg[i]=lg[i/2]+1,g[0][i]=p[i].num;\n    for(int i=1;i<=lg[n];i++){\n        for(int j=1;j+(1<<i)-1<=n;j++){\n            if(f1[i-1][j]<f1[i-1][j+(1<<(i-1))]){\n                f1[i][j]=f1[i-1][j+(1<<(i-1))];\n                g[i][j]=g[i-1][j+(1<<(i-1))];\n                f2[i][j]=max(f1[i-1][j],f2[i-1][j+(1<<(i-1))]);\n            }else if(f1[i-1][j]>f1[i-1][j+(1<<(i-1))]){\n                f1[i][j]=f1[i-1][j];\n                g[i][j]=g[i-1][j];\n                f2[i][j]=max(f2[i-1][j],f1[i-1][j+(1<<(i-1))]);\n            }else{\n                f1[i][j]=f1[i-1][j];\n                g[i][j]=-1;\n                f2[i][j]=max(f2[i-1][j],f2[i-1][j+(1<<(i-1))]);\n            }\n        }\n    }\n}\n\nnode query(int l,int r){\n    node ans;\n    int len=lg[r-l+1];\n    if(f1[len][l]>f1[len][r-(1<<len)+1]){\n        ans.k1=f1[len][l];\n        ans.idx=g[len][l];\n        ans.k2=max(f1[len][r-(1<<len)+1],f2[len][l]);\n    }else if(f1[len][l]<f1[len][r-(1<<len)+1]){\n        ans.k1=f1[len][r-(1<<len)+1];\n        ans.idx=g[len][r-(1<<len)+1];\n        ans.k2=max(f2[len][r-(1<<len)+1],f1[len][l]);\n    }else{\n        ans.k1=f1[len][l];\n        ans.k2=max(f2[len][l],f2[len][r-(1<<len)+1]);\n        if(g[len][l]==g[len][r-(1<<len)+1]) ans.idx=g[len][l];\n        else ans.idx=-1;\n    }\n    return ans;\n}\n\nint main(){\n\n    read(t);\n    while(t--){\n        read(n);mx=0;\n        for(int i=1;i<=n;i++) read(p[i].h),p[i].num=i,ans[i]=0;\n        for(int i=1;i<=n;i++) read(p[i].a),mx=max(mx,p[i].a);\n\n        sort(p+1,p+1+n,cmp);\n\n        for(int i=1;i<=n;i++) a[i]=p[i].a;\n\n        init();\n\n        for(int i=1;i<=mx;i++){\n            node tmp,ad;\n            ad.idx=0,ad.k1=0,ad.k2=0;\n            // cout<<i<<\" \"<<ceil((1.0*mx)/(1.0*i))<<endl;\n            for(int c=1;c<=ceil((1.0*mx)/(1.0*i));c++){\n                int l=lower_bound(a+1,a+n+1,i*(c-1)+1)-a;\n                int r=upper_bound(a+1,a+n+1,i*c)-a-1;\n                // cout<<i*(c-1)+1<<\" \"<<i*c<<\" \"<<l<<\" \"<<r<<endl;\n                if(l>r) continue;\n                tmp=query(l,r);\n                // cout<<l<<\" \"<<r<<\" \"<<tmp.k1<<\" \"<<tmp.idx<<\" \"<<tmp.k2<<endl;\n                if(tmp.k1*c>ad.k1){\n                    ad.k2=max(ad.k1,tmp.k2*c);\n                    ad.k1=tmp.k1*c;\n                    ad.idx=tmp.idx;\n                }else if(tmp.k1*c<ad.k1){\n                    ad.k2=max(ad.k2,tmp.k1*c);\n                }else{\n                    ad.idx=-1;\n                    ad.k2=max(ad.k2,tmp.k2*c);\n                }\n            }\n            // cout<<ad.k1<<\" \"<<ad.idx<<\" \"<<ad.k2<<endl;\n            if(ad.idx==-1) continue;\n            ans[ad.idx]=max(ans[ad.idx],ad.k1-ad.k2);\n        }\n\n        for(int i=1;i<=n;i++) cout<<ans[i]<<\" \";\n        cout<<endl;\n    }\n    \n\n    return 0;\n}\n```\n\n","tags":["CodeForces"],"categories":["算法"]},{"title":"ABC320","url":"/2023/09/19/ABC320/","content":"\n写在前面：$4/7$ 菜菜\n\n<!--more-->\n\n## A\n\n小小签到题，不能用 $pow$，会爆\n\n## B\n\n签到题，$O(n^3)$ 判回文\n\n# C\n\n老虎机\n\n先枚举数码，再枚举顺序，然后模拟，考码力\n\n# D\n\n双向建图跑 $dfs$ \n\n# E\n\n离散化后，排序模拟，要注意吃不到的情况，没有人退出或回来\n\n# F\n\nDP，不会做\n\n三维DP\n\n顺推，向外更新，比另一种方法好写多了\n\n会点了，但不想写了\n\n好像假了\n\n正推比逆推少过了仨点\n\n难受\n\n回头再说\n\n# G\n\n加强版老虎机\n\n二分+二分图\n\n暂时咕\n\n","tags":["Atcoder"],"categories":["算法"]},{"title":"AppleScript学习笔记","url":"/2023/09/16/AppleScript/","content":"\n写在前面：在搭建班级代码仓库时遇到了需要编写脚本的问题，所以来学习一下怎么编写 $AppleScript$，感觉用好了这门脚本语言 $mac$ 将会很强大\n\n<!--more-->\n\n我不用学了，因为 $ChatGPT$ 帮我学了\n\n脚本1：\n\n用来分类文件\n\n在文件夹1下有一些文件，文件名前两个数码为序号，在文件夹2下有一些文件夹，文件夹名为序号，现在要求运行脚本后，存在文件夹1下的所有文件按照序号复制一份到文件夹2下对应名字的文件夹下\n\n![](https://p.ipic.vip/1m6jw2.jpg)\n\n```applescript\n-- 设置文件夹路径\nset folder1Path to \"路径1\"\nset folder2Path to \"路径2\"\n\n-- 获取文件夹1中的所有文件\ntell application \"System Events\"\n\tset folder1Files to every file of folder folder1Path\nend tell\n\n-- 遍历文件并复制到相应的文件夹中\nrepeat with aFile in folder1Files\n\tset filePath to POSIX path of (aFile as alias)\n\tset fileName to name of aFile\n\t\n\t-- 提取文件名前两个数码作为序号\n\tset serialNumber to text 1 thru 2 of fileName\n\t\n\t-- 确定目标文件夹的路径\n\tset targetFolder to folder2Path & \"/\" & serialNumber\n\t\n\t-- 如果目标文件夹不存在，则创建它\n\tdo shell script \"mkdir -p \" & quoted form of POSIX path of targetFolder\n\t\n\t-- 使用 shell 命令复制文件\n\tdo shell script \"cp \" & quoted form of filePath & \" \" & quoted form of POSIX path of targetFolder\nend repeat\n\ndisplay dialog \"复制完成！\"\n```\n\n脚本2：\n\n用来创建文件夹\n\n在文件夹中创建名为 01、02、……、62 的总共62个文件夹。\n\n```Applescript\n-- 设置文件夹1路径\nset folder1Path to \"路径\" -- 请将路径替换为实际路径\n\n-- 创建文件夹\nrepeat with i from 1 to 62\n\tset folderNumber to text -2 thru -1 of (\"0\" & i) -- 将数字转为两位数格式，如1变为01\n\tset newFolderPath to folder1Path & \"/\" & folderNumber\n\tdo shell script \"mkdir -p \" & quoted form of newFolderPath\nend repeat\n\ndisplay dialog \"创建完成！\"\n```\n\n","tags":["AppleScript"],"categories":["语法"]},{"title":"CF1872","url":"/2023/09/08/CF1872/","content":"\n写在前面：$5/7$ 到学校第一次打 $CF$ 还算可以\n\n<!--more-->\n\n## A\n\n签到题，基本运算，读懂题即可\n\n> `ceil(x)` 是对 $x$ 向上取整，`floor(x)` 是对 $x$ 向下取整\n\n## B\n\n签到题，读懂题即可，线性扫陷阱\n\n## C\n\n小构造题，如果范围里有大于 $2$ 的偶数，那就输出 $x-2$ 和 $2$，如果只有一个奇数，那就分解因数，如果有除 $1$ 和它本身的因数，就输出此因数和 $x$ 与此因数的差，找不到就输出 $-1$，注意 $1,2,3$ 都不符合题意需特判 \n\n## D\n\n小数学题，发现 $x,y$ 的倍数数量相对于整体是少数，所以只需要考虑倍数，$x,y$ 的公倍数被加一次减一次相当于没用，于是我们求出来是 $x$ 的倍数但不是 $y$ 的倍数的个数以及是 $y$ 的倍数但不是 $x$ 的倍数的个数，依次把最大的若干数和最小的若干数填进去即可  \n\n## E\n\n看到几种做法\n\n\t1. 线段树（我的做法）\n \t2. 异或前缀和\n \t3. 分块\n\n感觉线段树还是比较好想的，维护区间内属于 $0$ 的异或和属于 $1$ 的异或和，修改就是 $swap$ 并打 $tag$，我做的时候出现了一些问题，导致样例能过，但是第二个点就过不去了，最后几分钟调出来了，发现是打 $tag$ 的方式不对，有的 $tag$ 不能及时下放，在 $tag$ 本来就为 $1$ 的节点再进行修改，$tag$ 应该变为 $0$，我忽略了这个问题，最后切了\n\n## F\n\n基环树森林的基本做法，先处理环下树一定最优，然后找环，环中舍掉贡献最少的边，定出一个起点按顺序输出，最劣复杂度 $O(n\\log n)$ \n\n> 在一个有向图中,每一个点都有唯一的一个出边,那么这个图就是一棵基环树。\n\n## G\n\n奇技淫巧题\n\n发现操作肯定是选非 $1$ 的数做两端更优，所以只需要枚举非 $1$ 的数，处理出前缀积和前缀和，然后 $O(n^2)$ 枚举，有人担心 $O(n^2)$ 过不了，其实确实过不了，考虑一些可以直接得出答案的情况，当一段数的积够大，大到一定程度，就一定取整段\n\n数据范围告诉我们如果什么操作都不做，所有数的和最大应该是 $2e14$，当积大于这个数时，就可以省去枚举的步骤，以 $2$ 为底其的对数不超过 $60$，枚举飞快\n\n第一次手撕 $G$ 题纪念一下","tags":["CodeForces"],"categories":["算法"]},{"title":"练一些分治题","url":"/2023/09/07/partition-problems/","content":"\n写在前面：分治这个东西好像容易被大家忘记，专门找一些题练练\n\n<!--more-->\n\n## [Luogu P1429]([P1429 平面最近点对（加强版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1429)) \n\n分治基本思想，确定一个分割点，各自处理左右两部分答案，最后合并答案\n\n先考虑一维，确定一个中间点，假设左右分别都求出来了最近点对，然后需要求整个部分的答案，需要考虑跨分界点的点对，设 $d$ 为左右两边答案中小的那个，只需要考虑分界点左右距离为 $d$ 内的点，至多有两个点，复杂度降到 $O(n\\log n)$ \n\n二维一样，按其中一维像上面做之后，把另一维排序，取靠近分界点的点进行枚举，枚举也无须做到平方级别，每个点只需要尽可能枚举相近的点即可，可以证明点数不超过 $6$ 个，复杂度降到 $O(n\\log n)$ \n\n## [LOJ \\#6490]([#6490. 「XXOI 2018」暑假时在做什么？有没有空？可以来学物理吗？ - 题目 - LibreOJ (loj.ac)](https://loj.ac/p/6490)) \n\n也是区间分成两半去考虑，当两边的答案处理好之后，需要考虑跨过 $mid$ 的区间\n\n以左边为例，依次枚举左端点 $i$，求出跨 $mid$ 的长度在 $[l,r]$ 的区间中最大的区间，具体用前缀和 + $st$ 表实现 $O(1)$ 查找，记录下来 $pre$ 再往后扫，$i$ 的答案就是 $max(ans[i],pre)$，$i$ 一定是在 $pre$ 记录的最大区间里面的\n\n右边同样，注意开要 $long\\ long$ \n\n","tags":["分治"],"categories":["算法"]},{"title":"你不是第一次当新生了，应该知道怎么做了吧","url":"/2023/09/06/new-student/","content":"\n开学了，写点东西\n\n<!--more-->\n\n## day -2\n\n大姨带着元宝来送我上火车，元宝一见到我就抱住我说：“哥哥你什么时候才回来看我啊”，真的佩服小孩子的记性，明明上了高中以后就没再见过一面了，却还是和我亲的不行\n\n在火车站坐着，大姨让我看着元宝，却带回来一袋子麦当劳，让我上车吃，姥姥的饺子还在保温杯里，大姨说容易坏，上车先把麦当劳吃了吧，然后我就在车上吧饺子和汉堡全吃了，撑得睡不着觉\n\nbtw 退役军人证是真的爽，人们排了好长的队，但是直接从队首进到站台了\n\n上车以后看了两集生活大爆炸就睡了，防止手机没电一直开着超级省电\n\n## day -1\n\n早晨七点起的，好像到湖南了，早饭吃了碗泡面就回卧铺上躺着了，还做成了一项伟业：把五个箱子袋子缩减到了四个\n\n南方的山和水比北方多多了，一会儿进一个隧道，一会儿跨一条湖，我坐在窗户前面看了一个多小时，好像被吸引住了，可能也是无聊\n\n中午12点到广州了，和我爸我妈会和，也是这个时候知道会有台风，辅导员说可以提前入住，然后我们就直接去华工了，先坐的 $9$ 号线，从广州北站到高增，再倒 $3$ 号线，从高增坐到汉溪长隆，最后倒 $7$ 号线，到终点站大学城南，不知道为什么，去一座城市，我就特别想坐一下，这个城市的地铁，就就就特别喜欢underground（北京地铁 $1$ 号线四惠前面的那段\n\n在志愿者的指引和导航的支持下找到了 $C10$，打开宿舍门发现 $wty$ 已经到了，我才想起来 $wty$ 是临干，简单认识了一下就开始收拾东西了，收拾了一下午，把蚊帐弄好了就溜了，晚上住的酒店还不错\n\n但是，酒店没有热水，我斗胆洗了发凉水澡，成功把自己弄感冒了，鼻子堵了，打喷嚏打个不停，没办法，还是睡了，睡前看到明天下午 $5$ 点以后让准备好吃的和用的，要停工停业，给我吓一哆嗦，但鼻子还是堵的，难受\n\n## day 0\n\n早晨六点，被一口气憋醒，然后就睡不着了，于是起来吃早饭，发现这里的店真的是开门好晚，七点都没几家点开门，吃了口上海小笼包就赶到学校了，继续收拾东西\n\n收拾了一上午以后看看还缺垃圾桶、盆等大件的生活用品，看到这里便利店真的卖的有点点小贵，在学校食堂吃了第一顿饭后，我们就打车到了最近的沃尔玛，说最近也不近，打车都花了四十多，后来一想，感觉还不如在学校买呢，打车都贵的要死\n\n下了车，不知道为啥感觉走不动道，累的不行，头也晕，有点烧，我妈觉得我又阳了，我也觉得，硬撑着买完了一些东西，打车回酒店睡了一下午，路上买了些药，吃了，好点，但不多\n\n晚上开始下雨了，是台风吗，可能是吧，说是 $2$ 号凌晨离我所在地最近，也不管啦，反正也病着，出不去\n\n家长回去的火车停运了，找了半天候补票，最后还是没订上\n\n## day 1\n\n今天报道，下着雨，吃了顿广东早茶就打车去华工了，收拾东西，线上报个到，去交个户口迁移证，该弄的都弄了\n\n发现病情有点改善\n\n我说，就在宿舍待着吧，他们说，订上票了\n\n看到 $wty$ 在看闫总的课，突然想起来高一的时候自己听闫总的课，觉得这怎么可能是从我们学校出来的，我怎么没学成这样，$noip$ 就退役的小 b 崽汁斗胆挑战 $ACM$，看后续吧\n\n跟 $wty$ 聊了会儿天，感觉是个大佬，作息规律，还学的多，感觉卷不过的样子 /qq\n\n跟 $wty$ 渗透了一下想当学习委员的意愿\n\n晚上 $lkf$ 买的洗衣机到了，只有我和 $wty$ 在宿舍，我们没管快递师傅带个推车的建议，空着手去了，然后抬着大洗衣机，从天桥底下走到宿舍底下，然后又搬上四楼，搬的满头大汗，得，病是完全好了\n\n在宿舍待的第一个晚上，我就知道了山东有多卷，反正比河北卷\n\n## day 2\n\n快七点起的，洗漱完，$wty$ 带我去见另外几个临干和他们的室友，先见到 $hyl$ 和 $lxj$，然后在食堂见到了 $zyw$ 和 $xzy$，和他们一块吃早饭，我要的煎饼，感觉和北方的做法不太一样，吃起来也还行，我们因为拿体检表晚来了点所以只是安静的吃（社恐\n\n估计是他们都提前见过了，对我还比较陌生，被 $zyw$ 问叫什么，好像又被认错名字里的字了，果然是个易错字，高中老师每人念错一遍的威力\n\n然后在黄老师的带领下逛了一圈校园，知道路怎么走啦，学校还是蛮大的嘛（赞赏\n\n然后去体育馆体检了，体育馆的屋顶好像某处遗址的材质，不是很懂\n\n去和家长告别，在正门拍了几张照片，在 $I ❤️ SCUT$ 那里拍了几张，最后吃一顿饭就回浙江了，我也带着点东西回宿舍了\n\n回到宿舍，$wty$ 又要去当志愿者，于是就我一个人了，和 $yzx$ 视频了会，聊挺开心，回来 $wty$ 就告诉我他也想当学习委员，好像有点棘手，我确实胜算不太大，戴耳机，听歌，洗衣服，晾上，$xby$ 来啦，帮他搬东西去，然后吃晚饭\n\n晚上自己骑着小蓝去 $GO GO$ 新天地了，人蛮多，蛮繁华，戴着耳机，人声听不到了，只有音乐声，找点好位置拍点照，看着，走着，突然发现自己是只有自己在这座城市上了，还好吧，有点说不出的感觉\n\n骑着车子姥姥给我打电话，第一个没接到，我说自己在洗衣服，我要是说我自己在外面逛，肯定又要被担心被拐走了\n\n感觉黄老师确实蟀\n\n## day 3\n\n报道第三天，早晨吃饭带上 $xby$ 了，$zyw$ 又认了一下，吃完去拿快递回宿舍了\n\n我跟 $wty$ 说我改成科创委员吧，我还是蛮好说话的（自豪\n\n下午我想出去玩，问他们去不去，然后就都去了，去的北京路，坐了一个小时地铁，到了一个比较古老又繁华的道路上，左边是古老的破旧不堪的建筑，残留着上个世纪的遗韵，右边是大商场，展示着繁华大都市的脸面，稍微转了转，在这里可以看到无轨电车，相当于公交，但是上面连着线，第一次见，新鲜事物\n\n去吃冰，点了个里面有芒果和奶皮的甜品还有抹茶味的（应该是）冰沙，做的好高，分量挺足，就是吃完容易窜，就像 $xby$ 一样\n\n然后我们去大沙头游船码头坐船去啦，一个人 $98$ 块钱，还可以，主要是江风太好吹了，感觉一切不好的事都能被它吹走，然后只留下享受，大桥从头顶上略过，广州塔从身旁游过，想用无人机拍下来这样的景象\n\n船上有专门的摄影师，先给你拍照，然后给你洗出来装上纸质相框，问你要三十块拿走，最后我们自己在船上拍了一张，能体会一次就不错\n\n今天最后一位同仁 $lkf$ 来了，$430$ 宿舍齐活，直接启动！\n\n## day 4\n\n因为明天要考试了，所以打算复习复习，上午听了个四级听力，错了 $4$ 个，再听一个，听不下去了，听不懂，然后开始写阅读，错了 $6$ 个，不写了\n\n拿快递，然后拿快递，然后更新桌面，二阶段宿舍改造计划启动\n\n晚上有学生会招新，去听了听，看中了三个：外联部、宣传部、学术科技部，最后报了外联和宣传\n\n试了下收音机，金属味有点重\n\n## day 5\n\n早晨吃完饭去照片采集，碰到 $zyw$， 看了看考场，回宿舍歇着了\n\n看了看单词，还是有点不放心收音效果，就没带收音机（惊（不是故意的（带了个空盒子（以为带上了，慌得我直接找旁边刚考完的人借了个，最后还没用到\n\n在 $B7$ 门口看到了 $CG$ 力（喜\n\n中午吃的意面，不好吃，差评\n\n取快递，三阶段宿舍改造计划启动\n\n晚上开学典礼，去食堂感觉不想吃，就买了瓶可乐去音乐厅后面的座位上歇着了，看 $Tim$ 说编程领域 $mac$ 的使用率还是比较高的，瞬间舒心\n\n听课听的很认真，有被教育到了，要好好学习咯，睡觉啦 /dy\n\n## day 6\n\n下了一天雨，在宿舍待了一整天，中午饭晚上饭都在宿舍吃零食，根本不想出宿舍\n\n上午敲了一上午代码，打了会音游，下午睡到 $2$ 点半，起来梦了会游，去面试外联部了，口才不太好，想到的都没说出来，感觉不是太妙\n\n晚上说是有集会但是大雨倾盆，逃了\n\n到床上打 $cf$ 找手感，切了 $5$ 道，感觉良好\n\n## day 7\n\n依然在下雨，上午是班级破冰活动，早上准备去，拿上新买的雨伞，但是发现坏了，我才用了一次啊 /dk，结果在楼下买了个高达 $38$ 元的雨伞，早饭都没吃就去了\n\n时间好像只有一个半小时，比较紧，让所有人简单介绍了下自己，然后又让班委竞选了一下（然而每个班委只有一个人竞选）没尬住，大胜利\n\n搞完去拿快递，发现都不知道自己取了哪个没取哪个，取了个寂寞，回来就在遇见小面找了个座位吃了 $40$ 块钱的软骨丸子汤面、羊肉串还有冰粉，还不错，就是有点贵\n\n回到宿舍发现自己耳机进水了一样，一直有电流声，md我快两百块钱买的啊，怎么这么不经用\n\n下午干正事\n\n晚上听詹书记教育我们，感觉讲课跟 $pjl$ 一样抽象，喜欢举例子，喜欢说看似废话的话，意识流式讲话，原来有学识的人都是这么讲话，爱了爱了\n\n## day 8\n\n今天上午是全校的开学典礼，下午是全校的新生安全教育，一散会就被叫去搬书了，分完书回宿舍写作业，写到半夜才写完\n\n## day 9\n\n今天早晨起晚了，赶忙去七楼面试宣传部，平稳地完成了，晚上告诉我通过了 yeah\n\n打算出去玩，简单找了找资料，首先先去坐了有轨电车，从万胜围到广州塔，发现那里有步行桥可以跨珠江，觉得傍晚来风景最好，就预约了六点到七点的时间，然后坐 $APM$ 线去广州图书馆和广州博物馆，座位和大厅是没有隔离连着的，感觉人多的话工作看书会有点吵，逛了一圈出来想去博物馆，发现需要预约并且当天已经预约满了，就只能换个地方去了，去了旁边的 $K11$ 艺术购物中心，上流人士的游览场所，有钢琴表演，金碧辉煌，我这种土狗逛了逛就溜了，溜去彩虹桥旁边的西华路吃小吃，彩虹桥确实是个很魔幻的地铁站，非常大，天花板上装饰着彩虹，西华路上人一般多，只有那么几家网红店门口排着长队，剩下的店里都看不到顾客，我点了一份煎饺还有一杯杨枝甘露，还是蛮好吃的，回图书馆看了会书，就去广州塔的步行桥上欣赏日落了，但是太阳看不见一点，扫兴地去五山校区听华南虎宣讲会了，看到好多名人，抽奖还中奖了（喜，想加入，但是再看看吧\n\n明天就开课了，新生记录就先这样完结吧，先让我学学怎么学习大学的知识……","tags":["life"],"categories":["生活"]},{"title":"四级作文备考","url":"/2023/08/08/English-articles/","content":"\n写在前面：没什么好写的，就是复习作文素材\n\n<!--more-->\n\n## ep1 Mobile Games\n\n​\tNowadays mobile phones have become an **inseparable** social networking tool for college students,which results in the popularity of mobile games.Evidently,they <u>exert a profound impact on</u> the life of **comtemporary** college students.\n\n​\tAdmittedly,playing mobile games <u>is a good way to</u> relieve stress and anxiety.<u>Interactive entertainment</u> provides **tangible** benefits,such as hand-eye **coordination**,the increase in brain's activity and the boost in creativity.Also,competitve games can improve participants' team-building skills,which are essential to their academic cooperation.\n\n​\tHowever,playing mobile games also has negative impacts on many college students.Some would become easily addicted to mobile games due to lack of self-control.Staring at mobile screens for many hours would lead to a **sedentary** lifestyle,causing **eyestrain** or headaches.Besides,too much exposure to violent languages and scenes will likely make college students more **aggressive**.\n\n​\tIn all,mobile games should be used <u>in a **rational** way</u>,and college students should <u>maximize their benefits</u> to achieve bigger success in their future life.\n\n## ep2 Online Shopping\n\n​\tBuying and selling online has become important parts of many people's lives.Consumers have <u>embraced</u> online shopping <u>as</u> a cheaper and more convenient way to buy what they want.However,the fact that shopping online is not really a cheap way cannot be **neglected**.\n\n​\tAttracted by <u>discount **coupons**</u> or other types of overwhelming promotions,consumers tend to **overspend** online.Sadly,<u>a large **proportion** of</u> those items they have bought online are later found unnecessary or useless.Once consumers want to return those items,they may be required to pay a return fee.Consumers also face losses on products like fruits and vegetables,which are very unlikely to be kept 100% fresh during transportation.Moreover,to achieve higher sales,**unscrupulous** businesses may display misleading,**exaggerated** and **fraudulent** information,leading to a higher risk of **fraud** and a huge loss of money for consumers.\n\n​\tTherefore,to enjoy a truly lower price of online products,we should go through websites carefully,and <u>think twice before</u> we choose to pay for the products.","tags":["English"],"categories":["英语"]},{"title":"康复训练","url":"/2023/08/06/training-1/","content":"写在前面：已经快一年没coding了，所以打算利用这一个月时间进行一个手感的找回，也好为 $ACM$ 打下基础\n\n<!--more-->\n\n## 2023.8.6\n\n### [leetcode 6953](https://leetcode.cn/problems/check-if-it-is-possible-to-split-array/) \n\n脑筋急转弯，正难则反\n\n### [leetcode 2813]([2813. 子序列最大优雅度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-elegance-of-a-k-length-subsequence/)) \n\n一开始没想到，看题解后知道是反悔贪心，然后就写了一个错误答案\n\n```c++\nclass Solution {\npublic:\n\n    struct cmp2{\n        bool operator()(const pair<int, int> &a, const pair<int, int> &b){\n                return a.first > b.first;\n        }\n    };\n\n    pair<int,int> s[100010];\n    priority_queue< pair<int,int> , vector<pair<int,int> >,cmp2 > p;\n    int n,tmp=0,lx=0,sum[100010];\n\n    static bool cmp1(pair<int,int> a,pair<int,int> b){\n        if(a.first==b.first) return a.second<b.second;\n        return a.first>b.first; \n    }\n\n    long long findMaximumElegance(vector<vector<int>>& items, int k) {\n        n=items.size();\n\n        for(int i=1;i<=n;i++){\n            s[i]=make_pair(items[i-1][0],items[i-1][1]);\n        }\n\n        sort(s+1,s+1+n,cmp1);\n\n        for(int i=1;i<=k;i++){\n            if(sum[s[i].second]==0){\n                lx++;\n                sum[s[i].second]=1;\n                tmp+=s[i].first;\n            }else{\n                sum[s[i].second]++;\n                tmp+=s[i].first;\n                p.push(make_pair(s[i].first,s[i].second));\n            }\n        }\n\n        tmp+=lx*lx;\n\n        if(p.empty()) return tmp;\n\n        for(int i=k+1;i<=n;i++){\n            if(sum[s[i].second]){continue;}\n            int tmp1=tmp;\n            while(!p.empty()&&sum[p.top().second]<=1) p.pop();\n            if(p.empty()) return tmp;\n            auto t=p.top();\n            tmp1-=t.first;\n            tmp1+=s[i].first;\n            tmp1-=lx*lx;\n            tmp1+=(lx+1)*(lx+1);\n            if(tmp1>tmp){\n                lx++;\n                tmp=tmp1;\n                p.pop();\n                sum[t.second]--;\n                sum[s[i].second]++;\n            }\n        }\n\n        return tmp;\n    }\n};\n```\n\n原谅我的马蜂，意思就是先按利润排序，然后先取前 $k$ 个，以取前 $k$ 个这个状态为基准，判断加进来一个会否会使结果变大，如果会那就取，再以这个状态为基准判断下一个，如果不会那就不取，相当于舍弃掉这个东西了\n\n$hack$ ：\n\n```\nitems=[[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[3,2],[3,3],[3,4],[3,5],[3,6],[3,7],[3,8],[3,9],[3,10],[3,11]] k=10\n```\n\n```\n137\n```\n\n正解是以前 $k$ 个这个状态为下界，然后尽可能往后取不同类别的东西，答案中类别数的平方使得线性的决策不一定正确，而贪心的思想告诉我们应该尽可能取不同类别的东西，严格来说正解才能称得上是贪心\n\n### [AGC064A]([A - i i's (atcoder.jp)](https://atcoder.jp/contests/agc064/tasks/agc064_a)) \n\n有点意思的构造题\n\n### [leetcode 1444]([1444. 切披萨的方案数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-ways-of-cutting-a-pizza/description/)) \n\n预处理+dp\n\n### [leetcode 1388]([1388. 3n 块披萨 - 力扣（LeetCode）](https://leetcode.cn/problems/pizza-with-3n-slices/)) \n\n问题转化+环形dp的经典题型，取不相邻的最值，去头去尾分别dp取最值，不然就得存到状态里\n\n### [ABC315E]([E - Prerequisites (atcoder.jp)](https://atcoder.jp/contests/abc315/tasks/abc315_e)) \n\n建反图统计 $1$ 的可达点，然后按拓扑序输出\n\n### [ABC315D]([D - Magical Cookies (atcoder.jp)](https://atcoder.jp/contests/abc315/tasks/abc315_d)) \n\n快学英语吧，题都看错了……\n\n### [ABC315F]([F - Shortcuts (atcoder.jp)](https://atcoder.jp/contests/abc315/tasks/abc315_f)) \n\n向后传递 $dp$ 题，注意不需要跳过太多点，只需要讨论跳过 $30$ 个以内的点的情况，于是可以把复杂度降到 $O(n^2)$ \n\n\n\n\n\n\n\n","tags":["C++"],"categories":["算法"]}]